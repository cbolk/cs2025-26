---
exe-start: 47
exepro-start: 58
---

# Python: data manipulation

+ pandas
    + reshape: `pivot`, `pivot_table` and `melt`

## Exercises in class



## Loading data

```Python
import pandas as pd
from datetime import datetime, timedelta


PATIENTS_FILE = "files/pd.trials.patient.csv"
TREATMENTS_FILE = "files/pd.trials.treatment.csv"
PAT_TREA_FILE = "files/pd.trials.patient_treatment.csv"
RESULTS_FILE = "files/pd.trials.lab_result.csv"

dfp = pd.read_csv(PATIENTS_FILE)
dft = pd.read_csv(TREATMENTS_FILE)
dfpt = pd.read_csv(PAT_TREA_FILE)
dfout = pd.read_csv(RESULTS_FILE)

# set dates with the appropriate type
dfp['EnrollDate'] = pd.to_datetime(dfp['EnrollDate'])
dfpt['StartDate'] = pd.to_datetime(dfpt['StartDate'])
dfout['VisitDate'] = pd.to_datetime(dfout['VisitDate'])

```

## Queries - in class

### Q. For each patient, report the lab results on their first visit

1. Find the first visit for each patient
2. Filter lab results to keep those entries only
3. **Reshape** to have a row per patient

```
#1. Find the first visit for each patient
# the date of the First Visit for each patient
dfpiddate = dfout.groupby('PID')["VisitDate"].min()
# add this date to each labresults

dfbase = pd.merge(dfout, dfpiddate, on='PID')
dfbase.rename(columns={"VisitDate_y": "FirstVisitDate"}, inplace=True)
dfbase.rename(columns={"VisitDate_x": "VisitDate"}, inplace=True)
# to avoid the double renaming, rename first the second column, so no duplicates
# dfbase = dfout.merge(
#   dfpiddate.rename(columns={"VisitDate": "FirstVisitDate"}),
#   on="PID"
#)


#2. Filter keeping all rows such that VisitDate is equal to FirstVisitDate
firstlabres = dfbase[dfbase["VisitDate"] == dfbase["FirstVisitDate"]]

#3. Reshape
patients_baseline = firstlabres.pivot(
    index="PID",
    columns="TestName",
    values="Value"
)
```

### Q. Compute a summary table showing the **mean baseline `HbA1c`** for each combination of `DrugName` (Metabolix, StandardCare, Placebo) and `Sex` (M, F). Display it as a matrix with DrugName as rows and Sex as columns.

Expected outcome:

```
Sex                   F          M
DrugName                          
Metabolix     ...   ...
Placebo       ...   ...
StandardCare  ...   ...
```

Steps:
1. Restrict to baseline HbA1c (earliest VisitDate per patient where TestName == 'HbA1c').
2. Reshape and compute mean

```Python
# select for the baseline tests only HbA1c results
dfbase[dfbase.TestName == 'HbA1c']

# merge for the patient the trial and the DrugName and the info on Sex

dfbase_all = pd.merge(dfbase, dfpt, on="PID")
dfbase_all = pd.merge(dfbase_all, dft, on="TrtID")
dfbase_all = pd.merge(dfbase_all, dfp, on="PID")


# in a single python-style chain
'''
dfbase_all = (
    dfbase
    .merge(dfpt, on="PID")
    .merge(dft, on="TrtID")
    .merge(dfp, on="PID")
)
'''

# create a table
table = dfbase_all.pivot_table(
     index="DrugName",
     columns="Sex",
     values="Value",
     aggfunc="mean"
)
```


### Q. or each DrugName, compute the mean HbA1c in two time windows relative to treatment start: 0–30 days and 31–60 days

Expected outcome:

```
Window            0-30     31-60
DrugName                        
Metabolix     ...  ...
Placebo       ...  ...
StandardCare  ...  ...
```

```Python
 Filter HbA1c lab results
hba1c = dfout[dfout['TestName'] == "HbA1c"]
# Merge in treatment assignment
hba1c_full = hba1c.merge(dfpt, on='PID')
hba1c_full = hba1c_full.merge(dft, on='TrtID')

# or
# hba1c_full = hba1c.merge(dfpt, on='PID').merge(dft, on='TrtID')

# compute the number of days since the treatment started
hba1c_full["DaysSinceStart"] = (hba1c_full["VisitDate"] - hba1c_full["StartDate"]).dt.days

# filter only those within 0 - 60
m60 = hba1c_full[(hba1c_full["DaysSinceStart"] >= 0) & (hba1c_full["DaysSinceStart"] <= 60)].copy()

# append a column with the window 0-30 31-60
m60.loc[m60.DaysSinceStart <= 30, "Window"] = "0-30"
m60.loc[m60.DaysSinceStart > 30,  "Window"] = "31-60"

# use the .cut method
'''
m60["Window"] = pd.cut(
    m60["DaysSinceStart"],
    bins=[-0.1, 30, 60],   # two bins 
    labels=["0-30", "31-60"]
)
'''

# create a table ... but pivot_table needed
summary = m60.pivot(
    index="DrugName",
    columns="Window",
    values="Value"
)

# >>> ValueError: Index contains duplicate entries, cannot reshape

summary = m60.pivot_table(
    index="DrugName",
    columns="Window",
    values="Value",
    aggfunc="mean"
)

```

### Q. Report for every patient and every visit, the lab results, and compute a _Risk_ index that combines contributions as:
`Risk = 0.8 * HbA1c + 0.03 * LDL + 0.02 * Weight_kg + 0.05 * Systolic_BP`


Expected outcome:

```
TestName        HbA1c    LDL  Systolic_BP  Weight_kg
PID VisitDate                                       
101 2025-01-31    6.4  133.0        151.0      105.5
    2025-03-04    6.3  126.0        173.0       96.7
    2025-05-03    6.7   98.0        154.0       94.3
102 2025-01-11    5.8  127.0        153.0       74.3
    2025-02-12    5.5   90.0        138.0      100.7
...               ...    ...          ...        ...
159 2025-05-12    6.8   81.0        123.0       94.1
    2025-07-11    7.7   66.0        154.0       58.7
160 2025-03-15    8.8  106.0        127.0       91.0
    2025-04-16    8.5  119.0        150.0       80.0
    2025-06-15    5.6  128.0        155.0       59.3

```

or better

```
PID  VisitDate  HbA1c    LDL  Systolic_BP  Weight_kg
0         101 2025-01-31    6.4  133.0        151.0      105.5
1         101 2025-03-04    6.3  126.0        173.0       96.7
2         101 2025-05-03    6.7   98.0        154.0       94.3
3         102 2025-01-11    5.8  127.0        153.0       74.3
4         102 2025-02-12    5.5   90.0        138.0      100.7
..        ...        ...    ...    ...          ...        ...
152       159 2025-05-12    6.8   81.0        123.0       94.1
153       159 2025-07-11    7.7   66.0        154.0       58.7
154       160 2025-03-15    8.8  106.0        127.0       91.0
155       160 2025-04-16    8.5  119.0        150.0       80.0
156       160 2025-06-15    5.6  128.0        155.0       59.3
```


```Python

# reset index is needed because we have two columns 

lab_wide = dfout.pivot_table(
    index=["PID", "VisitDate"],
    columns="TestName",
    values="Value"
)

# or

lab_wide = dfout.pivot_table(
    index=["PID", "VisitDate"],
    columns="TestName",
    values="Value"
).reset_index()

# risk computation
HBA1C_MULT  = 0.8
LDL_MULT    = 0.03
WEIGHT_MULT = 0.02
BP_MULT     = 0.05

# or

lab_wide["Risk"] = HBA1C_MULT * lab_wide["HbA1c"] + LDL_MULT * lab_wide["LDL"] +  WEIGHT_MULT * lab_wide["Weight_kg"] + BP_MULT * lab_wide["Systolic_BP"]

# alternative 

def compute_risk(row):
    score = (
        HBA1C_MULT * row.get("HbA1c", 0) +
        LDL_MULT * row.get("LDL", 0) +
        WEIGHT_MULT * row.get("Weight_kg", 0) +
        BP_MULT * row.get("Systolic_BP", 0)
    )
    return score

lab_wide["Risk"] = lab_wide.apply(compute_risk, axis=1)

```



### Q. Add a second Risk column, RiskXYZ, computed according to the following rule:
+ Start with risk = 0
+ Add 2 points if HbA1c > 8
+ Add 1 point if LDL > 160
+ Add 2 points if LDL > 160 AND Weight > 100
+ Add 3 extra points if Systolic_BP is rising compared to last visit
+ Add 5 points if HbA1c > 7 AND LDL > 150 AND Weight > 95
+ Cap the maximum at 10

```Python
def compute_risk_xyz(row):
    risk = 0
    
    if row["HbA1c"] > 8:
        risk += 2
    if row["LDL"] > 160:
        risk += 1
    if row["LDL"] > 160 and row["Weight_kg"] > 100:
        risk += 2
    if row["Systolic_BP_Change"] > 0:
        risk += 3
    if (row["HbA1c"] > 7 and row["LDL"] > 150 and row["Weight_kg"] > 95):
        risk += 5

    # Cap max at 10
    return min(risk, 10)

lab_wide["RiskXYZ"] = lab_wide.apply(compute_risk_xyz, axis=1)

```

### Q. Given a selected PID, create a report showing the subsequent lab results. Create a simple flow that asks the user to select a PID within the set of available ones, and it computes and shows, in a readble format, for all available visits, the lab results.

Expected outcome (for PID 130):

```
VisitDate 2025-03-05                              2025-04-18         ...  2025-06-01           2025-07-17                             
TestName       HbA1c    LDL Systolic_BP Weight_kg      HbA1c    LDL  ... Systolic_BP Weight_kg      HbA1c    LDL Systolic_BP Weight_kg
PID                                                                  ...                                                              
130              8.6  113.0       120.0     107.3        5.6  146.0  ...       150.6      59.3        8.8  110.0       125.0     103.3

```

```Python
# ask the user for a valid PID in the existing range
PIDfrom = dfp[['PID']].min()
PIDto = dfp[['PID']].max()
print(f'PID ([{PIDfrom.iloc[0]}, {PIDto.iloc[0]}])')
selPID = int(input())
while selPID not in dfp['PID'].values::
    print(f'PID ([{PIDfrom.iloc[0]}, {PIDto.iloc[0]}])')
    selPID = int(input())

# get lab results for the selected PID
dfresp = dfout[dfout.PID == selPID]


# get a table
dfresp_tab = dfresp.pivot_table(
    index ="PID",
    columns = ["VisitDate","TestName"],
    values = "Value"
)

# try

dfresp_tab = dfresp.pivot_table(
    index ="PID",
    columns = ["TestName", "VisitDate"],
    values = "Value"
)

## for plotting purposes
dfresp_plot = dfresp.pivot(
    index="VisitDate",
    columns="TestName",
    values="Value"
).sort_index()

```

### Q. How many patients have enrolled per site per month


Expected result:
```
    SiteID EnrollMonth  PID
0   LON-05     2025-01   10
1   LON-05     2025-02    4
2   LON-05     2025-03    6
3   LON-05     2025-04    2
4   LON-05     2025-05    5
5    NY-01     2025-01    3
6    NY-01     2025-02    4
...
```


```Python
# identify the month
dfp["EnrollMonth"] = dfp['EnrollDate'].dt.to_period('M')

# group by site, month
enroll_counts = dfp.groupby(['SiteID', 'EnrollMonth'])['PID'].count().reset_index()

# Better column name
enroll_counts.rename(columns={'PID': 'NumPatients'}, inplace=True)


plot_df = enroll_counts.pivot(
    index='EnrollMonth',
    columns='SiteID',
    values='NumPatients'
).fillna(0)


plot2_df = enroll_counts.pivot(
    index='SiteID',
    columns='EnrollMonth',
    values='NumPatients'
).fillna(0)
```

```python
# PER SITE


ax = plot_df.plot(kind='bar', figsize=(10,6))

plt.xlabel("Enrollment Month")
plt.ylabel("Number of Patients")
plt.title("Patients Enrolled Per Site Per Month")
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

## stacked

ax = plot_df.plot(kind='bar', stacked=True, figsize=(10, 6))

plt.xlabel("Enrollment Month")
plt.ylabel("Number of Patients")
plt.title("Patients Enrolled per Site per Month (Stacked)")
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

## line

ax = plot_df.plot(kind='line', figsize=(10,6))

plt.xlabel("Enrollment Month")
plt.ylabel("Number of Patients")
plt.title("Patients Enrolled Per Site Per Month")
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()


# PER MONTH

ax = plot2_df.plot(kind='bar', figsize=(10,6))

plt.xlabel("Site")
plt.ylabel("Number of Patients")
plt.title("Patients Enrollment Per Month Per Site")
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()
```

