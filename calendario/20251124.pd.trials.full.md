## Dataset

1. `patient`: Patient information

| Column        | Type   | Description                         |
| ------------- | ------ | ----------------------------------- |
| PID           | Int    | Unique identifier for the patient   |
| Age           | Int    | Age of the patient at enrollment    |
| Sex           | String | Biological sex ('M' or 'F')         |
| SiteID        | String | Code for the hospital/clinic        |
| EnrollDate    | Date   | The date the patient signed         |

Sample Data:

| PID | Age | Sex | SiteID | EnrollDate |
| :--- | :--- | :--- | :--- | :--- |
| 101 | 55 | M | NY-01 | 2023-01-10 |
| 102 | 62 | F | LON-05 | 2023-01-12 |
| 103 | 44 | M | NY-01 | 2023-01-15 |


2. `treatment`: This describes the drugs conceptually.

| Column        | Type   | Description                                                           |
| ------------- | ------ | --------------------------------------------------------------------- |
| TrtID         | Int    | Treatment ID                                                          |
| DrugName      | String | The treatment administered: 'Metabolix', 'StandardCare', or 'Placebo' |
| StudyArm      | String | Protocol type: 'Experimental', 'ActiveControl', or 'PlaceboControl'   |


Sample Data:

| TrtID | DrugName | StudyArm |
| :--- | :--- | :--- |
| T01 | Metabolix | Experimental |
| T02 | StandardCare | Control |
| T03 | Placebo | PlaceboControl |


3. `patient_treatment`: This table links the patient and the treatment it is associated with, and specifies the prescription.

| Column        | Type   | Description                                                           |
| ------------- | ------ | --------------------------------------------------------------------- |
| PID           | Int    | Patient ID                                                            |
| TrtID         | Int    | Treatment ID                                                          |
| StartDate     | Date   | The date the patient started taking the medication                    | 
| Dosage_mg     | Int    | Daily dosage in milligrams (e.g., 10, 20, 50)                         |


Sample Data:

| PID  | TrtID|  StartDate  | Dosage_mg |
| :--- | :--- | :--- | :--- |
|101   | T01  |2023-01-15   | 20
|102   | T03  |2023-01-20   | 0


4. `lab_result` This table contains longitudinal data (measurements taken over time). 

| Column        | Type   | Description                                                              |
| ------------- | ------ | ------------------------------------------------------------------------ |
| LabID         | Int    | Unique identifier for the specific lab test instance                     |
| PID           | Int    | Foreign key linking to the patient                                       |
| VisitDate     | Date   | The date the measurement was taken                                       |
| TestName      | String | The type of metric measured ('HbA1c', 'Systolic_BP', 'LDL', 'Weight_kg') |
| Value         | Float  | The numerical result of the measurement                                  |


Sample Data:

| LabID | PID | VisitDate | TestName | Value |
| :--- | :--- | :--- | :--- | :--- |
| 1 | 101 | 2023-01-10 | HbA1c | 7.2 |
| 2 | 101 | 2023-01-10 | Weight_kg | 88.5 |
| 3 | 101 | 2023-02-10 | HbA1c | 6.9 |
| 4 | 102 | 2023-01-12 | Systolic_BP | 140.0 |


## Visual relationships

![Data relationships](./images/pd.trials.png)

## Loading data

```Python
import pandas as pd
from datetime import datetime, timedelta


PATIENTS_FILE = "files/pd.trials.patient.csv"
TREATMENTS_FILE = "files/pd.trials.treatment.csv"
PAT_TREA_FILE = "files/pd.trials.patient_treatment.csv"
RESULTS_FILE = "files/pd.trials.lab_result.csv"

dfp = pd.read_csv(PATIENTS_FILE)
dft = pd.read_csv(TREATMENTS_FILE)
dfpt = pd.read_csv(PAT_TREA_FILE)
dfout = pd.read_csv(RESULTS_FILE)

# set dates with the appropriate type
dfp['EnrollDate'] = pd.to_datetime(dfp['EnrollDate'])
dfpt['StartDate'] = pd.to_datetime(dfpt['StartDate'])
dfout['VisitDate'] = pd.to_datetime(dfout['VisitDate'])

```

## Queries

### Q. List the last 10 patients who enrolled in the trial program

```Python
last_10_patients = (
    dfp
    .sort_values('EnrollDate', ascending=False)  # Sort by date, newest first
    .head(10)                                     # Take first 10 rows
)
```

or

```Python
last_10_patients = dfp.nlargest(10, 'EnrollDate')
```

### Q. Show all the trials started in March, reporting ID and starting date in a sorted way with respect to starting date.

```Python
dfpt[dfpt['StartDate'].dt.month == 3].sort_values('StartDate', ascending=True).reset_index(drop=True)[['TrtID','StartDate']]
```

### Q. Show the complete list of all enrolled patients, showing their ID, sex, and the name of the drug they were assigned to.

Expected outcome:

```
PID Sex      DrugName
101   M     Metabolix
102   F  StandardCare
103   F       Placebo
104   M     Metabolix
```

```Python
# let us combine patients and their trial information
dfptreat = pd.merge(dfp, dfpt, on='PID')
# adding also the information on the treatment
dffull = pd.merge(dfptreat, dft, on='TrtID')

result = dffull[['PID', 'Sex', 'DrugName']]
```

### Q. Identify all patients over the age of 60 who were assigned to the _Metabolix_ protocol, reporting their IDs and ages.

```python
dffull[(dffull.Age > 60) & (dffull.DrugName == 'Metabolix')][['PID','Age']]
```

This solution requires two steps:
1. Row filtering: a temporary intermediate copy of the DataFrame containing all the columns is created for the matching rows
2. Column selection: the temporary DataFrame is sliced to keep only the two columns

Alternative solution:

```python
dffull.loc[
    (dffull.Age > 60) & (dffull.DrugName == 'Metabolix'), 
    ['PID', 'Age']
]
```

Single Access: it only extracts the specific data points (intersection of those rows and those columns).

### Q. Check the prescriptions at the New York (_NY-01_) site: list every patient in that site showing which drug they are on and the dosage they were prescribed.

```python
dffull.loc[
    (dffull.SiteID == 'NY-01'), 
    ['PID', 'DrugName','Dosage_mg']
]
```

### Q. Verify the randomization for the _Placebo_ group: retrieve the number of females and males in such a group (create two variables numPlaM and numPlaF and print them).


```python
numPlaMF = dffull.loc[
    (dffull.DrugName == 'Placebo'), 
    ['Sex']
].value_counts()

# it returns an array with names
'''
Sex
M      8
F      2
Name: count, dtype: int64
'''

numPlaM = numPlaMF['M']
numPlaF = numPlaMF['F']

```

Alternative solution

```python
# Get gender distribution in Placebo group
numPlaMF = (
    dffull[dffull['DrugName'] == 'Placebo']         # Filter for Placebo drug
    ['Sex']                                         # Select only Sex column
    .value_counts()                                 # Count occurrences of each sex
    .sort_index()                                   # Sort by Sex (F, M)
)

```

### Q. What is the average _Systolic Blood Pressure_ (TestName is _Systolic_BP_) across the entire study population, regardless of what drug they are on?

```python
# separate mask to filter rows
bpmask = (dfout['TestName'] == 'Systolic_BP')

# creating an intermediate dataFrame

dfbp = dfout[bpmask]
avgBloodPressure = dfbp['Value'].mean()

#or 

dfbp = dfout.loc[bpmask]
avgBloodPressure = dfbp['Value'].mean()

# we do not really need the intermediate dataframe
# without creating an intermediate dataframe
avgBloodPressure = dfout.loc[bpmask,'Value'].mean()

```

### Q. Compare the three study arms. What is the average _HbA1c_ level for the _Metabolix_ group, compared to _StandardCare_ and the _Placebo_ group

Method:

1. **Split** data into groups (by Drug).
2. **Apply** a function (Mean).
3. **Combine** the results into a new table.


```python
# 0. Combine treatments and lab_results for the same patient
dftpout = pd.merge(dfpt, dfout, on='PID')
dftpout = pd.merge(dftpout, dft, on='TrtID')


# 1. Filter: Select only HbA1c records
df_hba1c = dftpout.loc[dftpout.TestName == 'HbA1c']

# 2. GroupBy: Calculate the mean value per Drug
# syntax: df.groupby('Grouping_Column')['Math_Column'].mean()
dfres = df_hba1c.groupby('DrugName')['Value'].mean().reset_index(name='avgHbA1c')
```

### Q. What is the single _highest LDL value_ recorded for any patient on the _Experimental_ protocol?

```python
# Define the protocol you are looking for (e.g., 'Experimental', 'ActiveControl', or 'PlaceboControl')
protocol = 'Experimental'

# Filter dftpout for:
# 1. The specific TestName ('LDL')
# 2. The specific StudyArm
highest_ldl = dftpout[
    (dftpout['TestName'] == 'LDL') & 
    (dftpout['StudyArm'] == protocol)
]['Value'].max()

```

### Q. List all lab results (ID, Test, Value, Date) that were taken _before_ the patient's medication Start Date, this sets the baseline data

1. We need to bring the StartDate (from the treatment table) onto the results table so that every lab row has a "reference date" to compare against -> merge
2. Keep rows where VisitDate < StartDate -> filter

```python
mask = (dftpout['VisitDate'] < dftpout['StartDate'])

baseline_data = dftpout.loc[
    mask, 
    ['LabID', 'TestName', 'Value', 'VisitDate', 'StartDate']
]

print(baseline_data.head())
```

### Q. Calculate the average number of days between a patient's _Enrollment Date_ and their treatment _Start Date_, by _Site ID_.

1. Join patients (Enroll Date & Site) with patient_treatment (Start Date) -> merge (`dffull`)
2. Create a new column called deltaTime by subtracting EnrollDate from StartDate and extract the number of days.
3. Group by SiteID and average the numbers -> `group by` and `average`


```python
dffull['deltaTime'] = dffull['StartDate'] - dffull['EnrollDate']
dffull['deltaDays'] = dffull['deltaTime'].dt.days

# also in a single step
dffull['deltaDays'] = (dffull['StartDate'] - dffull['EnrollDate']).dt.days
# group and average
dfDeltaDays = dffull.groupby('SiteID')['deltaDays'].mean().reset_index(name='avgDeltaDays')
```

### Q. Are there any 'Waiting Patients'? List the IDs of any patients who are enrolled in the system but have no associated treatment so far

Looking for patients that do not have an entry in `patient_treatments`

```python
# the important part is **left**
dftmp = pd.merge(dfp, dfpt, on='PID', how='left')

dftmp.loc[dftmp.TrtID.isna(),'PID']
```

### Q. Are there any 'Ghost Patients'? List the IDs of any patients who are enrolled in the system but have _zero_ lab results recorded in the database so far

Similar

```python
dftmp = pd.merge(dfp, dfout, on='PID', how='left')
dftmp.loc[dftmp.LabID.isna(),'PID']

## alternative using isin

# take all PIDs of patients whose PID is not in results
dfp[~dfp['PID'].isin(dfout['PID'])]['PID']
```

### Q. When looking at _Metabolix_ users specifically, is there a difference in average _Weight_ between Male and Female patients in that group?

`Metabolix` is the `DrugName` for the patients we are interested in. For those data, we need to compute the average `Weight_kg` for the different groups based on `Sex`.

```python
# Merge dftout with dfp to have also the sex information
dfall = pd.merge(dftpout, dfp, on='PID')

# Filter the data for:
#  - DrugName: 'Metabolix'
#  - TestName: 'Weight_kg'
metabolix_weight = dfall[
    (dfall['DrugName'] == 'Metabolix') & 
    (dfall['TestName'] == 'Weight_kg')
]

# Group by Sex and calculate the average (mean) Value
avgWeight = metabolix_weight.groupby('Sex')['Value'].mean()

```

### Q. List patient IDs for anyone who has ever recorded a _Systolic BP > 160_ OR an _LDL > 150_ at any point in the study

```python
# selection based on 
# Condition 1: Test is Systolic_BP AND Value is > 160
# OR (|)
# Condition 2: Test is LDL AND Value is > 150
highRisk_filter = (
    ((dftpout['TestName'] == 'Systolic_BP') & (dftpout['Value'] > 160)) | 
    ((dftpout['TestName'] == 'LDL') & (dftpout['Value'] > 150))
)

# Apply the filter to get the rows, select the PID column, 
# and get unique values (so a patient isn't listed twice)
fdrisk = list(dftpout.loc[highRisk_filter, 'PID'].unique())

```

### Q. Which treatment is associated with the largest reduction in _HbA1c_ over the first 60 days? Identify whether _Metabolix_ (Experimental arm) outperforms _StandardCare_ or _Placebo_ in glycemic improvements

Calculate the change in HbA1c for every patient by comparing their Baseline results (before start date) to their Follow-up results (within the first 60 days of treatment). Group the patients by their assigned DrugName and tell me which group had the largest average reduction.

1. Combine all 4 tables (results + patient_treatment + treatments) so every row knows the Date, the Test Value, and the Drug.
2. Filter only 'HbA1c' rows.
3. Calculate Days since Start: 
    - < 0: Label as 'Baseline'.
    - [0, 60] FollowUp
    - > 60: Ignore.
4. Reshape so every Patient (PID) has a Baseline column and a FollowUp column side-by-side.
5. Calculate Delta: Baseline - FollowUp.
6. Aggregate: Group by DrugName and average the Delta.


```python
# select 'HbA1c' (making a copy)
dfexam = dftpout.loc[dftpout['TestName'] == 'HbA1c'].copy()
dfexam['DaysOnDrug'] = (dfexam['VisitDate'] - dfexam['StartDate']).dt.days

```

### Q. Which patient has the most data points? Find the Patient ID associated with the _highest number of individual lab records_.

```python
# 1. Group by PID and count the LabIDs (or any column)
# This creates a Series where index=PID and value=Count
counts = dftpout.groupby('PID')['LabID'].count().reset_index(name='NumberRecords')

# 2. Sort descending to get the highest at the top
top_row = counts.sort_values(by='NumberRecords', ascending=False).head(1)

# 3. Show the top patient
print(top_row['PID'].iloc[0])

```

### Q. Create a summary table with _one row per patient_, showing their average monitored values in separate columns

Reshaping

```python
# Create the Pivot Table
# We use pivot_table() instead of pivot() because we have multiple dates.
# We need to AGGREGATE (mean) the values from different dates into one number.
dfout_sum = dfout.pivot_table(
    index='PID',           # What defines the rows?
    columns='TestName',    # What defines the new column headers?
    values='Value',        # What numbers go inside?
    aggfunc='mean'         # How do we combine multiple visits? (Average)
).reset_index()

```


### Q. For each patient, report the lab results on their first visit

1. Find the first visit for each patient
2. Filter lab results to keep those entries only
3. **Reshape** to have a row per patient

```
#1. Find the first visit for each patient
# the date of the First Visit for each patient
dfpiddate = dfout.groupby('PID')["VisitDate"].min()
# add this date to each labresults

dfbase = pd.merge(dfout, dfpiddate, on='PID')
dfbase.rename(columns={"VisitDate_y": "FirstVisitDate"}, inplace=True)
dfbase.rename(columns={"VisitDate_x": "VisitDate"}, inplace=True)
# to avoid the double renaming, rename first the second column, so no duplicates
# dfbase = dfout.merge(
#   dfpiddate.rename(columns={"VisitDate": "FirstVisitDate"}),
#   on="PID"
#)


#2. Filter keeping all rows such that VisitDate is equal to FirstVisitDate
firstlabres = dfbase[dfbase["VisitDate"] == dfbase["FirstVisitDate"]]

#3. Reshape
patients_baseline = firstlabres.pivot(
    index="PID",
    columns="TestName",
    values="Value"
)
```

### Q. Compute a summary table showing the **mean baseline `HbA1c`** for each combination of `DrugName` (Metabolix, StandardCare, Placebo) and `Sex` (M, F). Display it as a matrix with DrugName as rows and Sex as columns.

Expected outcome:

```
Sex                   F          M
DrugName                          
Metabolix     ...   ...
Placebo       ...   ...
StandardCare  ...   ...
```

Steps:
1. Restrict to baseline HbA1c (earliest VisitDate per patient where TestName == 'HbA1c').
2. Reshape and compute mean

```Python
# select for the baseline tests only HbA1c results
dfbase[dfbase.TestName == 'HbA1c']

# merge for the patient the trial and the DrugName and the info on Sex

dfbase_all = pd.merge(dfbase, dfpt, on="PID")
dfbase_all = pd.merge(dfbase_all, dft, on="TrtID")
dfbase_all = pd.merge(dfbase_all, dfp, on="PID")


# in a single python-style chain
'''
dfbase_all = (
    dfbase
    .merge(dfpt, on="PID")
    .merge(dft, on="TrtID")
    .merge(dfp, on="PID")
)
'''

# create a table
table = dfbase_all.pivot_table(
     index="DrugName",
     columns="Sex",
     values="Value",
     aggfunc="mean"
)
```


### Q. or each DrugName, compute the mean HbA1c in two time windows relative to treatment start: 0–30 days and 31–60 days

Expected outcome:

```
Window            0-30     31-60
DrugName                        
Metabolix     ...  ...
Placebo       ...  ...
StandardCare  ...  ...
```

```Python
 Filter HbA1c lab results
hba1c = dfout[dfout['TestName'] == "HbA1c"]
# Merge in treatment assignment
hba1c_full = hba1c.merge(dfpt, on='PID')
hba1c_full = hba1c_full.merge(dft, on='TrtID')

# or
# hba1c_full = hba1c.merge(dfpt, on='PID').merge(dft, on='TrtID')

# compute the number of days since the treatment started
hba1c_full["DaysSinceStart"] = (hba1c_full["VisitDate"] - hba1c_full["StartDate"]).dt.days

# filter only those within 0 - 60
m60 = hba1c_full[(hba1c_full["DaysSinceStart"] >= 0) & (hba1c_full["DaysSinceStart"] <= 60)].copy()

# append a column with the window 0-30 31-60
m60.loc[m60.DaysSinceStart <= 30, "Window"] = "0-30"
m60.loc[m60.DaysSinceStart > 30,  "Window"] = "31-60"

# use the .cut method
'''
m60["Window"] = pd.cut(
    m60["DaysSinceStart"],
    bins=[-0.1, 30, 60],   # two bins 
    labels=["0-30", "31-60"]
)
'''

# create a table ... but pivot_table needed
summary = m60.pivot(
    index="DrugName",
    columns="Window",
    values="Value"
)

# >>> ValueError: Index contains duplicate entries, cannot reshape

summary = m60.pivot_table(
    index="DrugName",
    columns="Window",
    values="Value",
    aggfunc="mean"
)

```

### Q. Report for every patient and every visit, the lab results, and compute a _Risk_ index that combines contributions as:
`Risk = 0.8 * HbA1c + 0.03 * LDL + 0.02 * Weight_kg + 0.05 * Systolic_BP`


Expected outcome:

```
TestName        HbA1c    LDL  Systolic_BP  Weight_kg
PID VisitDate                                       
101 2025-01-31    6.4  133.0        151.0      105.5
    2025-03-04    6.3  126.0        173.0       96.7
    2025-05-03    6.7   98.0        154.0       94.3
102 2025-01-11    5.8  127.0        153.0       74.3
    2025-02-12    5.5   90.0        138.0      100.7
...               ...    ...          ...        ...
159 2025-05-12    6.8   81.0        123.0       94.1
    2025-07-11    7.7   66.0        154.0       58.7
160 2025-03-15    8.8  106.0        127.0       91.0
    2025-04-16    8.5  119.0        150.0       80.0
    2025-06-15    5.6  128.0        155.0       59.3

```

or better

```
PID  VisitDate  HbA1c    LDL  Systolic_BP  Weight_kg
0         101 2025-01-31    6.4  133.0        151.0      105.5
1         101 2025-03-04    6.3  126.0        173.0       96.7
2         101 2025-05-03    6.7   98.0        154.0       94.3
3         102 2025-01-11    5.8  127.0        153.0       74.3
4         102 2025-02-12    5.5   90.0        138.0      100.7
..        ...        ...    ...    ...          ...        ...
152       159 2025-05-12    6.8   81.0        123.0       94.1
153       159 2025-07-11    7.7   66.0        154.0       58.7
154       160 2025-03-15    8.8  106.0        127.0       91.0
155       160 2025-04-16    8.5  119.0        150.0       80.0
156       160 2025-06-15    5.6  128.0        155.0       59.3
```


```Python

# reset index is needed because we have two columns 

lab_wide = dfout.pivot_table(
    index=["PID", "VisitDate"],
    columns="TestName",
    values="Value"
)

# or

lab_wide = dfout.pivot_table(
    index=["PID", "VisitDate"],
    columns="TestName",
    values="Value"
).reset_index()

# risk computation
HBA1C_MULT  = 0.8
LDL_MULT    = 0.03
WEIGHT_MULT = 0.02
BP_MULT     = 0.05

# or

lab_wide["Risk"] = HBA1C_MULT * lab_wide["HbA1c"] + LDL_MULT * lab_wide["LDL"] +  WEIGHT_MULT * lab_wide["Weight_kg"] + BP_MULT * lab_wide["Systolic_BP"]

# alternative 

def compute_risk(row):
    score = (
        HBA1C_MULT * row.get("HbA1c", 0) +
        LDL_MULT * row.get("LDL", 0) +
        WEIGHT_MULT * row.get("Weight_kg", 0) +
        BP_MULT * row.get("Systolic_BP", 0)
    )
    return score

lab_wide["Risk"] = lab_wide.apply(compute_risk, axis=1)

```



### Q. Add a second Risk column, RiskXYZ, computed according to the following rule:
+ Start with risk = 0
+ Add 2 points if HbA1c > 8
+ Add 1 point if LDL > 160
+ Add 2 points if LDL > 160 AND Weight > 100
+ Add 3 extra points if Systolic_BP is rising compared to last visit
+ Add 5 points if HbA1c > 7 AND LDL > 150 AND Weight > 95
+ Cap the maximum at 10

```Python
def compute_risk_xyz(row):
    risk = 0
    
    if row["HbA1c"] > 8:
        risk += 2
    if row["LDL"] > 160:
        risk += 1
    if row["LDL"] > 160 and row["Weight_kg"] > 100:
        risk += 2
    if row["Systolic_BP_Change"] > 0:
        risk += 3
    if (row["HbA1c"] > 7 and row["LDL"] > 150 and row["Weight_kg"] > 95):
        risk += 5

    # Cap max at 10
    return min(risk, 10)

lab_wide["RiskXYZ"] = lab_wide.apply(compute_risk_xyz, axis=1)

```

### Q. Given a selected PID, create a report showing the subsequent lab results. Create a simple flow that asks the user to select a PID within the set of available ones, and it computes and shows, in a readble format, for all available visits, the lab results.

Expected outcome (for PID 130):

```
VisitDate 2025-03-05                              2025-04-18         ...  2025-06-01           2025-07-17                             
TestName       HbA1c    LDL Systolic_BP Weight_kg      HbA1c    LDL  ... Systolic_BP Weight_kg      HbA1c    LDL Systolic_BP Weight_kg
PID                                                                  ...                                                              
130              8.6  113.0       120.0     107.3        5.6  146.0  ...       150.6      59.3        8.8  110.0       125.0     103.3

```

```Python
# ask the user for a valid PID in the existing range
PIDfrom = dfp[['PID']].min()
PIDto = dfp[['PID']].max()
print(f'PID ([{PIDfrom.iloc[0]}, {PIDto.iloc[0]}])')
selPID = int(input())
while selPID not in dfp['PID'].values::
    print(f'PID ([{PIDfrom.iloc[0]}, {PIDto.iloc[0]}])')
    selPID = int(input())

# get lab results for the selected PID
dfresp = dfout[dfout.PID == selPID]


# get a table
dfresp_tab = dfresp.pivot_table(
    index ="PID",
    columns = ["VisitDate","TestName"],
    values = "Value"
)

# try

dfresp_tab = dfresp.pivot_table(
    index ="PID",
    columns = ["TestName", "VisitDate"],
    values = "Value"
)

## for plotting purposes
dfresp_plot = dfresp.pivot(
    index="VisitDate",
    columns="TestName",
    values="Value"
).sort_index()

```

### Q. How many patients have enrolled per site per month


Expected result:
```
    SiteID EnrollMonth  PID
0   LON-05     2025-01   10
1   LON-05     2025-02    4
2   LON-05     2025-03    6
3   LON-05     2025-04    2
4   LON-05     2025-05    5
5    NY-01     2025-01    3
6    NY-01     2025-02    4
...
```


```Python
# identify the month
dfp["EnrollMonth"] = dfp['EnrollDate'].dt.to_period('M')

# group by site, month
enroll_counts = dfp.groupby(['SiteID', 'EnrollMonth'])['PID'].count().reset_index()

# Better column name
enroll_counts.rename(columns={'PID': 'NumPatients'}, inplace=True)


plot_df = enroll_counts.pivot(
    index='EnrollMonth',
    columns='SiteID',
    values='NumPatients'
).fillna(0)


plot2_df = enroll_counts.pivot(
    index='SiteID',
    columns='EnrollMonth',
    values='NumPatients'
).fillna(0)
```

```python
# PER SITE


ax = plot_df.plot(kind='bar', figsize=(10,6))

plt.xlabel("Enrollment Month")
plt.ylabel("Number of Patients")
plt.title("Patients Enrolled Per Site Per Month")
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

## stacked

ax = plot_df.plot(kind='bar', stacked=True, figsize=(10, 6))

plt.xlabel("Enrollment Month")
plt.ylabel("Number of Patients")
plt.title("Patients Enrolled per Site per Month (Stacked)")
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

## line

ax = plot_df.plot(kind='line', figsize=(10,6))

plt.xlabel("Enrollment Month")
plt.ylabel("Number of Patients")
plt.title("Patients Enrolled Per Site Per Month")
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()


# PER MONTH

ax = plot2_df.plot(kind='bar', figsize=(10,6))

plt.xlabel("Site")
plt.ylabel("Number of Patients")
plt.title("Patients Enrollment Per Month Per Site")
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()
```
