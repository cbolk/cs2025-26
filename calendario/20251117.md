---
exe-start: 37
exepro-start: 51
---

# Python: files

+ identification: path (relative | absolute) name extension
+ open (mode)
+ access
+ close

## Exercises in class

::: exefatti

**Q1**: Which of the following statements about functions are TRUE? (Select all that apply)

1. A function should ideally perform one well-defined task or operation
2. All functions must return a value to be useful
3. Using functions helps avoid code duplication and improves maintainability
4. Variables defined inside a function are accessible throughout the entire program

**Q2**: 

Consider the following function concepts. Which statements are TRUE? (Select all that apply)

1. Passing a list to a function creates a copy, so modifications inside the function don't affect the original list
2. The order of arguments matters when calling a function with positional parameters
3. A function with no parameters (empty parentheses) cannot perform any useful computation
4. To set a value to a parameter received by a function, the function should perform a request to the user (e.g. using the `input()` statement)

**Q3**: 

Which of the following represent good practices or true statements about return values? (Select all that apply)
1. A function should return results rather than print them, making the function more reusable
2. Once a return statement executes, no further code in that function will run
3. Functions that modify their input parameters should also return those modified values
4. A function without an explicit return statement cannot be useful

::: 

::: exefatti

Write a program that given a DNA sequence finds the corresponding RNA strand and computes and prints the encoding of specific codons into the amino acid alphabet. The mapping between codon and amino  acids is reported below:

# Genetic Code Table

| 2nd Base → |     | **U** | **C** | **A** | **G** |     |
|------------|-----|-------|-------|-------|-------|-----|
| **1st ↓** | **3rd →** | | | | | |
| **U** | U | **UUU** Phe (F) | **UCU** Ser (S) | **UAU** Tyr (Y) | **UGU** Cys (C) | U |
|  | C | **UUC** Phe (F) | **UCC** Ser (S) | **UAC** Tyr (Y) | **UGC** Cys (C) | C |
|  | A | **UUA** Leu (L) | **UCA** Ser (S) | **UAA** STOP (*) | **UGA** STOP (*) | A |
|  | G | **UUG** Leu (L) | **UCG** Ser (S) | **UAG** STOP (*) | **UGG** Trp (W) | G |
| **C** | U | **CUU** Leu (L) | **CCU** Pro (P) | **CAU** His (H) | **CGU** Arg (R) | U |
|  | C | **CUC** Leu (L) | **CCC** Pro (P) | **CAC** His (H) | **CGC** Arg (R) | C |
|  | A | **CUA** Leu (L) | **CCA** Pro (P) | **CAA** Gln (Q) | **CGA** Arg (R) | A |
|  | G | **CUG** Leu (L) | **CCG** Pro (P) | **CAG** Gln (Q) | **CGG** Arg (R) | G |
| **A** | U | **AUU** Ile (I) | **ACU** Thr (T) | **AAU** Asn (N) | **AGU** Ser (S) | U |
|  | C | **AUC** Ile (I) | **ACC** Thr (T) | **AAC** Asn (N) | **AGC** Ser (S) | C |
|  | A | **AUA** Ile (I) | **ACA** Thr (T) | **AAA** Lys (K) | **AGA** Arg (R) | A |
|  | G | **AUG** Met (M) START | **ACG** Thr (T) | **AAG** Lys (K) | **AGG** Arg (R) | G |
| **G** | U | **GUU** Val (V) | **GCU** Ala (A) | **GAU** Asp (D) | **GGU** Gly (G) | U |
|  | C | **GUC** Val (V) | **GCC** Ala (A) | **GAC** Asp (D) | **GGC** Gly (G) | C |
|  | A | **GUA** Val (V) | **GCA** Ala (A) | **GAA** Glu (E) | **GGA** Gly (G) | A |
|  | G | **GUG** Val (V) | **GCG** Ala (A) | **GAG** Glu (E) | **GGG** Gly (G) | G |

## Notes:
- **Standard Genetic Code** (using U for RNA; substitute T for DNA)
- **Start Codon:** AUG (codes for Methionine)
- **Stop Codons:** UAA, UAG, UGA (marked with *)
- **Single-letter codes** in parentheses
- **Three-letter abbreviations** shown for amino acids

Example:

```
input: ATGGCCATGGCGCCCAGAACTGAGATCAATAGTACCCGTATTAACGGGTGA
output: MAMAPRTEINSTRINGStop
```

```python
# MAIN FLOW
# ask the user the DNA string
# convert into the RNA strand
# create an empty result string
# for each codon (sequence of three elements)
    # find the corresponding encoding
    # append it to the result
```

```python
DNAELEM = 'T'
RNAELEM = 'U'
CODON_SIZE = 3
END = "Stop"
ERROR = "Error"

GENETIC_CODE_1 = {
    'UUU': 'F', 'UUC': 'F', 'UUA': 'L', 'UUG': 'L',
    'UCU': 'S', 'UCC': 'S', 'UCA': 'S', 'UCG': 'S',
    'UAU': 'Y', 'UAC': 'Y', 'UAA': '*', 'UAG': '*',
    'UGU': 'C', 'UGC': 'C', 'UGA': '*', 'UGG': 'W',
    'CUU': 'L', 'CUC': 'L', 'CUA': 'L', 'CUG': 'L',
    'CCU': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',
    'CAU': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',
    'CGU': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',
    'AUU': 'I', 'AUC': 'I', 'AUA': 'I', 'AUG': 'M',
    'ACU': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',
    'AAU': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',
    'AGU': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',
    'GUU': 'V', 'GUC': 'V', 'GUA': 'V', 'GUG': 'V',
    'GCU': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',
    'GAU': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',
    'GGU': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G'
}

def codon2aa(seq, d):
    dim = len(seq)

    # create an empty result string
    aaseq = ""
    # for each codon (sequence of three elements)
        # find the corresponding encoding
        # append it to the result
    pos = 0
    last_pos = dim - CODON_SIZE
    while pos < last_pos:
        codon = seq[pos:pos+CODON_SIZE]
        if codon in d:
            aa = d[codon]
            aaseq += aa
            pos += CODON_SIZE
        else:
            print(f"codon {codon} not found")
            return aaseq + ERROR
    aaseq += END
    return aaseq

# MAIN FLOW
# ask the user the DNA string
dnaseq = input()
# convert into the RNA strand
rnaseq = dnaseq.replace(DNAELEM, RNAELEM)
aastring = codon2aa(rnaseq, GENETIC_CODE_1)
print(aastring)
```

[file](../codice/90.dna2aa.nofile.py)

Version with file and with `try-except`.

```python
DNAELEM = 'T'
RNAELEM = 'U'
CODON_SIZE = 3
END = "Stop"
ERROR = "Error"
SEP = ","

def loadcodontableshort(fname):
    codon_dic = {}
    try: 
        with open(fname, 'r', newline='') as infile:
            for line in infile:
                parts = line.strip().split(SEP)
                codon_dic[parts[0]] = parts[3]
    except:
        print(f"File {fname} not accessible")
    return codon_dic

def codon2aa(seq, d):
    dim = len(seq)

    # create an empty result string
    aaseq = ""
    # for each codon (sequence of three elements)
        # find the corresponding encoding
        # append it to the result
    pos = 0
    last_pos = dim - CODON_SIZE
    while pos < last_pos:
        codon = seq[pos:pos+CODON_SIZE]
        try:
            aa = d[codon]
            aaseq += aa
            pos += CODON_SIZE
        except:
            print(f"codon {codon} not found")
            return aaseq + ERROR
    aaseq += END
    return aaseq

# MAIN FLOW
# ask the user the DNA string
dnaseq = input()
# load the file with the mapping
filename = input()
# convert into the RNA strand
rnaseq = dnaseq.replace(DNAELEM, RNAELEM)
d = loadcodontableshort(filename)
if d:
    aastring = codon2aa(rnaseq, d)
    print(aastring)

```

[file](../codice/90.dna2aa.file.py)

Version with a csv file access

```python
import csv

DNAELEM = 'T'
RNAELEM = 'U'
CODON_SIZE = 3
END = "Stop"
ERROR = "Error"
SEP = ","

def loadcodontableshort(fname):
    codon_dic = {}
    try: 
        with open(fname, 'r', newline='') as infile:
            reader = csv.DictReader(infile)
            for row in reader:
                codon = row['Codon']
                one_letter = row['1Letter']
                codon_dic[codon] = one_letter
    except FileNotFoundError:
        print(f"File {fname} not accessible")
    return codon_dic

def codon2aa(seq, d):
    dim = len(seq)

    # create an empty result string
    aaseq = ""
    # for each codon (sequence of three elements)
        # find the corresponding encoding
        # append it to the result
    pos = 0
    last_pos = dim - CODON_SIZE
    while pos < last_pos:
        codon = seq[pos:pos+CODON_SIZE]
        try:
            aa = d[codon]
            aaseq += aa
            pos += CODON_SIZE
        except:
            print(f"codon {codon} not found")
            return aaseq + ERROR
    aaseq += END
    return aaseq

# MAIN FLOW
# ask the user the DNA string
dnaseq = input()
# load the file with the mapping
filename = input()
# convert into the RNA strand
rnaseq = dnaseq.replace(DNAELEM, RNAELEM)
d = loadcodontableshort(filename)
if d:
    aastring = codon2aa(rnaseq, d)
    print(aastring)
```

[file](../codice/90.dna2aa.filecsv.py)

:::

::: exefatti

Write a Python function that reads a text file containing nucleotide sequences of genetic samples and determines how many of these samples contain a specific _marker_ sequence indicating a mutation. The function receives as parameters the name of the file to with the nucleotide sequences and a string containing the marker and computes and returns the number of sequences that include the marker. Should the function have problem accessing the file, it returns -1.

```python
def countmarkers(filename, marker):
    try:
        res = 0
        with open(filename, "r") as filein:
            for line in filein:
                if marker in line.strip(): # useless to keep counting line.strip().count(marker) > 0:
                    res += 1

    except FileNotFoundError:
        res = -1
    except:
        res = -1
     return res
```

:::

## Proposed exercises

::: exepro
Write a Python function that reads a FASTA file containing protein sequences and identifies which proteins contain **all** of a set of conserved domain sequences. FASTA format consists of:

+ A header line starting with > (sequence identifier)
+ One or more lines of sequence data

The function receives as parameter in input `filename` and `domains`, a filename and a list of domain sequences (strings), respetively.
The function should return a list of protein identifiers (header lines without the `>`) that contain **all** specified domains. Should the file not be accessible, the function returns an empty list.

Example FASTA file content `myfile.fasta`:

```
>Protein_Alpha
MKTAYIAKQRQISFVKSHFSRQLEERLGLIEVQAPILSRVGDGTQDNLSGAEKAVQVKVKALPDAQFEVVHSLAKWKRQTLGQHDFSAGEGLYTHMKALRPDEDRLSPLHSVYVDQWDWERVMGDGERQFSTLKSTVEAIWAGIKATEAAVSEEFGLAPFLPDQIHFVHSQELLSRYPDLDAKGRERAIAKDLGAVFLVGIGGKLSDGHRHDVRAPDYDDWSTPSELGHAGLNGDILVWNPVLEDAFELSSMGIRVDADTLKHQLALTGDEDRLELEWHQALLRGEMPQTIGGGIGQSRLTMLLLQLPHIGQVQAGVWPAAVRESVPSLL
>Protein_Beta
ARNDCEQGHILKMFPSTWYV
>Protein_Gamma
MKTIALIVERQGHILKMFPNDCEQGSTLQIAPKNDCEQG
```

Execution example:

```
input: filename = "myfile.fasta" domains = ["QRQI", "LPDAQF"]
output: ["Protein_Alpha"]

input: filename = "myfile.fasta" domains = ["KMFP"]
output: ['Protein_Beta', 'Protein_Gamma']
```

```python
HEADERSTART = '>'

def getSequencesWithDomains(filename, domains):
    res = []
    try:
        with open(filename, "r") as filein:
            # number of domains
            num = len(domains)
            # list of sequences to be returned
            #read the header
            line = filein.readline().strip()
            while line and line[0] == HEADERSTART:
                seqname = line[1:]  #name of the sequence
                #read the entire sequence 
                seq = ""
                line = filein.readline().strip()
                while line and line[0] != HEADERSTART:
                    seq += line
                    line = filein.readline().strip()
                # the sequence is concluded
                # check if all domains are in
                allin = domains[0] in seq
                d = 1
                while allin and d < num:
                    if not domains[d] in seq:
                        allin = False
                    else:
                        d += 1
                if allin:
                    res.append(seqname)
            # no more lines
    except FileNotFoundError:
        print(f"problems accessing file {filename}")
    return res
```

::: 