---
exe-start: 37
exepro-start: 51
---

# Python: files

+ identification: path (relative | absolute) name extension
+ flow of operation
    - open (mode)
    - access
    - close

+ exception handling
    - `try-except`

## Exercises in class

::: exefatti

**Q1**: Which of the following statements about functions are TRUE? (Select all that apply)

1. A function should ideally perform one well-defined task or operation **TRUE**
2. All functions must return a value to be useful
3. Using functions helps avoid code duplication and improves maintainability **TRUE**
4. Variables defined inside a function are accessible throughout the entire program

**Q2**: 

Consider the following function concepts. Which statements are TRUE? (Select all that apply)

1. Passing a list to a function creates a copy, so modifications inside the function don't affect the original list
2. The order of arguments matters when calling a function with positional parameters **TRUE**
3. A function with no parameters (empty parentheses) cannot perform any useful computation
4. To set a value to a parameter received by a function, the function should perform a request to the user (e.g. using the `input()` statement)

**Q3**: 

Which of the following represent good practices or true statements about return values? (Select all that apply)
1. A function should return results rather than print them, making the function more reusable **TRUE**
2. Once a return statement executes, no further code in that function will run **TRUE**
3. Functions that modify their input parameters should also return those modified values
4. A function without an explicit return statement cannot be useful

::: 

::: exefatti

Write a program that given a DNA sequence finds the corresponding RNA strand and computes and prints the encoding of specific codons into the amino acid alphabet. The mapping between codon and amino  acids is reported below:

# Genetic Code Table

| 2nd Base → |     | **U** | **C** | **A** | **G** |     |
|------------|-----|-------|-------|-------|-------|-----|
| **1st ↓** | **3rd →** | | | | | |
| **U** | U | **UUU** Phe (F) | **UCU** Ser (S) | **UAU** Tyr (Y) | **UGU** Cys (C) | U |
|  | C | **UUC** Phe (F) | **UCC** Ser (S) | **UAC** Tyr (Y) | **UGC** Cys (C) | C |
|  | A | **UUA** Leu (L) | **UCA** Ser (S) | **UAA** STOP (*) | **UGA** STOP (*) | A |
|  | G | **UUG** Leu (L) | **UCG** Ser (S) | **UAG** STOP (*) | **UGG** Trp (W) | G |
| **C** | U | **CUU** Leu (L) | **CCU** Pro (P) | **CAU** His (H) | **CGU** Arg (R) | U |
|  | C | **CUC** Leu (L) | **CCC** Pro (P) | **CAC** His (H) | **CGC** Arg (R) | C |
|  | A | **CUA** Leu (L) | **CCA** Pro (P) | **CAA** Gln (Q) | **CGA** Arg (R) | A |
|  | G | **CUG** Leu (L) | **CCG** Pro (P) | **CAG** Gln (Q) | **CGG** Arg (R) | G |
| **A** | U | **AUU** Ile (I) | **ACU** Thr (T) | **AAU** Asn (N) | **AGU** Ser (S) | U |
|  | C | **AUC** Ile (I) | **ACC** Thr (T) | **AAC** Asn (N) | **AGC** Ser (S) | C |
|  | A | **AUA** Ile (I) | **ACA** Thr (T) | **AAA** Lys (K) | **AGA** Arg (R) | A |
|  | G | **AUG** Met (M) START | **ACG** Thr (T) | **AAG** Lys (K) | **AGG** Arg (R) | G |
| **G** | U | **GUU** Val (V) | **GCU** Ala (A) | **GAU** Asp (D) | **GGU** Gly (G) | U |
|  | C | **GUC** Val (V) | **GCC** Ala (A) | **GAC** Asp (D) | **GGC** Gly (G) | C |
|  | A | **GUA** Val (V) | **GCA** Ala (A) | **GAA** Glu (E) | **GGA** Gly (G) | A |
|  | G | **GUG** Val (V) | **GCG** Ala (A) | **GAG** Glu (E) | **GGG** Gly (G) | G |

## Notes:
- **Standard Genetic Code** (using U for RNA; substitute T for DNA)
- **Start Codon:** AUG (codes for Methionine)
- **Stop Codons:** UAA, UAG, UGA (marked with *)
- **Single-letter codes** in parentheses
- **Three-letter abbreviations** shown for amino acids

Example:

```
input: ATGGCCATGGCGCCCAGAACTGAGATCAATAGTACCCGTATTAACGGGTGA
output: MAMAPRTEINSTRINGStop
```

```python
# MAIN FLOW
# ask the user the DNA string
# convert into the RNA strand
# create an empty result string
# for each codon (sequence of three elements)
    # find the corresponding encoding
    # append it to the result
```

```python
DNAELEM = 'T'
RNAELEM = 'U'
CODON_SIZE = 3
END = "Stop"
ERROR = "Error"

GEN_CODE = {
    'UUU': 'F', 'UUC': 'F', 'UUA': 'L', 'UUG': 'L',
    'UCU': 'S', 'UCC': 'S', 'UCA': 'S', 'UCG': 'S',
    'UAU': 'Y', 'UAC': 'Y', 'UAA': '*', 'UAG': '*',
    'UGU': 'C', 'UGC': 'C', 'UGA': '*', 'UGG': 'W',
    'CUU': 'L', 'CUC': 'L', 'CUA': 'L', 'CUG': 'L',
    'CCU': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',
    'CAU': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',
    'CGU': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',
    'AUU': 'I', 'AUC': 'I', 'AUA': 'I', 'AUG': 'M',
    'ACU': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',
    'AAU': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',
    'AGU': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',
    'GUU': 'V', 'GUC': 'V', 'GUA': 'V', 'GUG': 'V',
    'GCU': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',
    'GAU': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',
    'GGU': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G'
}

'''
receives in input a string and a dictionary and 
converts the slices of the string according to the dictionary
'''
def codon2aa(seq, d):
    dim = len(seq)

    # create an empty result string
    aaseq = ""
    # for each codon (sequence of three elements)
        # find the corresponding encoding
        # append it to the result
    pos = 0
    last_pos = dim - CODON_SIZE
    while pos < last_pos:
        codon = seq[pos:pos+CODON_SIZE]
        if codon in d:
            aa = d[codon]
            aaseq += aa
            pos += CODON_SIZE
        else:   # the codon is not in the dictionary
            print(f"codon {codon} not found")
            # useless to continue
            return aaseq + ERROR
    aaseq += END
    return aaseq

# MAIN FLOW
# ask the user the DNA string
dnaseq = input()
# convert into the RNA strand
rnaseq = dnaseq.replace(DNAELEM, RNAELEM)
aastring = codon2aa(rnaseq, GEN_CODE)
print(aastring)
```

[file](../codice/40.dna2aa.nofile.py)

Having to write the dictionary in the program file is not ideal: only for developers, not easily maintanable. It is better to have a separate file to be uploaded and used.

*Version with file* The information on the encoding is stored in a file with a given name: `codonAAtable.csv`

```python
FILENAME = "codonAAtable.csv"
SEP = ","

DNAELEM = 'T'
RNAELEM = 'U'
CODON_SIZE = 3
END = "Stop"
ERROR = "Error"

def loadcodontableshort(fname, separator):
    codon_dic = {}
    with open(fname, 'r') as fin:
        #first line contains the header
        strheader = fin.readline()
        #all the remaining lines have the corresponding values
        for line in fin:
            parts = line.strip().split(separator)
            codon = parts[0]
            aa = parts[3]
            codon_dic[codon] = aa
            # or directly
            # codon_dic[parts[0]] = parts[3]
    return codon_dic

def codon2aa(seq, d):
    dim = len(seq)

    # create an empty result string
    aaseq = ""
    # for each codon (sequence of three elements)
        # find the corresponding encoding
        # append it to the result
    pos = 0
    last_pos = dim - CODON_SIZE
    while pos < last_pos:
        codon = seq[pos:pos+CODON_SIZE]
        if codon in d:
            aa = d[codon]
            aaseq += aa
            pos += CODON_SIZE
        else:   # the codon is not in the dictionary
            print(f"codon {codon} not found")
            # useless to continue
            return aaseq + ERROR
    aaseq += END
    return aaseq

# MAIN FLOW
# ask the user the DNA string
dnaseq = input()
# convert into the RNA strand
rnaseq = dnaseq.replace(DNAELEM, RNAELEM)
d = loadcodontableshort(FILENAME, SEP)
aastring = codon2aa(rnaseq, d)
print(aastring)

```

[file](../codice/40.dna2aa.file.1.py)


**Note**: Even if function `loadcodontableshort` has access to the name of the file and the adopted separator (it could be organised to directly access constants FILENAME and SEP) it is more flexible to design it like this because it can be reused in other contexts, by passing the name of the file and the separator without having to adapt the name of the constants storing the information. The code below can only work (without any fix) in a situation where `FILENAME` and `SEP` exist and have the right values.


```python
def loadcodontableshort():
    codon_dic = {}
    with open(FILENAME, 'r') as fin:
        #first line contains the header
        strheader = fin.readline()
        #all the remaining lines have the corresponding values
        for line in fin:
            parts = line.strip().split(SEP)
            codon = parts[0]
            aa = parts[3]
            codon_dic[codon] = aa
            # or directly
            # codon_dic[parts[0]] = parts[3]
    return codon_dic
```

*Version with file and access problems*. Use of `try-except` statement.


```python
DNAELEM = 'T'
RNAELEM = 'U'
CODON_SIZE = 3
END = "Stop"
ERROR = "Error"
SEP = ","

def loadcodontableshort(fname):
    codon_dic = {}
    try: 
        with open(fname, 'r', newline='') as infile:
            for line in infile:
                parts = line.strip().split(SEP)
                codon_dic[parts[0]] = parts[3]
    except:
        print(f"File {fname} not accessible")
    return codon_dic

def codon2aa(seq, d):
    dim = len(seq)

    # create an empty result string
    aaseq = ""
    # for each codon (sequence of three elements)
        # find the corresponding encoding
        # append it to the result
    pos = 0
    last_pos = dim - CODON_SIZE
    while pos < last_pos:
        codon = seq[pos:pos+CODON_SIZE]
        try:
            aa = d[codon]
            aaseq += aa
            pos += CODON_SIZE
        except:
            print(f"codon {codon} not found")
            return aaseq + ERROR
    aaseq += END
    return aaseq

# MAIN FLOW
# ask the user the DNA string
dnaseq = input()
# load the file with the mapping
rnaseq = dnaseq.replace(DNAELEM, RNAELEM)
d = loadcodontableshort(FILENAME, SEP)
# to be more robust, in case there is a problem accessing the file
if d:
    aastring = codon2aa(rnaseq, d)
    print(aastring)

```

[file](../codice/40.dna2aa.file.2.py)

:::

::: exefatti

Write a Python program that asks the user the name of a text file and counts and visualises the number of characters in the file.

```python
# get the name of the file
# remove possible trailing spaces at the end
filename = input().strip()

# unique read operation
# everything is stored in a string
with open(filename, "r") as fin:
    text = fin.read()
    dim = len(text)
print(dim)

# read one character at the time
with open(filename, "r") as fin:
    dim = 0
    c = fin.read(1) #read one character
    while c:    # while I have read something
        dim += 1
        c = fin.read(1)
print(dim)
```

[file](../codice/41.file.numcharsinfile.py)

:::


::: exefatti

Write a Python program that asks the user the name of a text file and counts and visualises the number of lines in the file.

```python
# get the name of the file
# remove possible trailing spaces at the end
filename = input().strip()

with open(filename) as fin:
    numlines = 0
    for line in fin:
        numlines += 1

    print(numlines)


## using statement readline() instead of for 
with open(filename) as fin:
    numlines = 0
    line = fin.readline()
    while line:
        numlines += 1
        line = fin.readline()
    print(numlines)

## reading all lines in a single operation
with open(filename) as fin:
    lines = fin.readlines()
    #lines = ["content of the first line", "content 2nd line"]
    numlines = len(lines)
    print(numlines)

```

[file](../codice/42.file.linesinfile.py)

:::


::: exefatti

Write a program that accepts integer values from the user until 0 is introduced. The program saves values that are prime in file `primes.txt`

```python
STOP = 0
FNAME = "primes.txt"

def prime(n):
    # 1 and even numbers greater than 2 are not prime
    if (n == 1) or (n % 2 == 0 and n > 2):
        return False
    div = 3
    while div * div <= n:
        if n % div == 0:
            return False
        else:
            div += 2
    return True

with open(FNAME, "w") as fout:
    val = int(input())
    while val != STOP:
        if prime(val):
            #write the number and add the newline after it
            fout.write(str(val) + "\n")
        val = int(input())

```

[file](../codice/43.file.saveprimes.py)

:::

## Proposed exercises

::: exepro

Write a Python program that asks the user two names of files, one for odd numbers, the other for even numbers. The program then asks the user a sequence of integer values and saves the odd ones in the first file, the even ones in the second file. The program stops accepting integer values when 0 is inserted. The program at the end visualises two values, the number of odd values and the number of even ones.

```python
STOP = 0

fnameodd = input()
fnameeven = input()

with open(fnameodd, "w") as fodd:
    with open(fnameeven, "w") as feven:
        nodd = 0
        neven = 0
        val = int(input())
        while val != STOP:
            if val % 2 == 1:
                fodd.write(str(val) + "\n")
                nodd += 1
            else:
                feven.write(str(val) + "\n")
                neven += 1
            val = int(input())

print(nodd, neven)
```


[file](../codice/90.file.splitoddeven.py)

:::


::: exepro

Write a Python function that receives in input two names of files `src` and `dst`. File `src` contains a sequence of integer values, one per line. The program reads from file `src` the numbers and saves in file `dst` only those numbers that are prime.

:::

::: exepro

Write a Python function that reads a text file containing nucleotide sequences of genetic samples and determines how many of these samples contain a specific _marker_ sequence indicating a mutation. The function receives as parameters the name of the file to with the nucleotide sequences and a string containing the marker and computes and returns the number of sequences that include the marker. Should the function have problem accessing the file, it returns -1.

```python
def countmarkers(filename, marker):
    try:
        res = 0
        with open(filename, "r") as filein:
            for line in filein:
                if marker in line.strip(): # useless to keep counting line.strip().count(marker) > 0:
                    res += 1

    except FileNotFoundError:
        res = -1
    except:
        res = -1
     return res
```


[file](../codice/90.countmarkers.py)


:::


::: exepro
Write a Python function that reads a FASTA file containing protein sequences and identifies which proteins contain **all** of a set of conserved domain sequences. FASTA format consists of:

+ A header line starting with > (sequence identifier)
+ One or more lines of sequence data

The function receives as parameter in input `filename` and `domains`, a filename and a list of domain sequences (strings), respetively.
The function should return a list of protein identifiers (header lines without the `>`) that contain **all** specified domains. Should the file not be accessible, the function returns an empty list.

Example FASTA file content `myfile.fasta`:

```
>Protein_Alpha
MKTAYIAKQRQISFVKSHFSRQLEERLGLIEVQAPILSRVGDGTQDNLSGAEKAVQVKVKALPDAQFEVVHSLAKWKRQTLGQHDFSAGEGLYTHMKALRPDE
DRLSPLHSVYVDQWDWERVMGDGERQFSTLKSTVEAIWAGIKATEAAVSEEFGLAPFLPDQIHFVHSQELLSRYPDLDAKGRERAIAKDLGAVFLVGIGGKLS
DGHRHDVRAPDYDDWSTPSELGHAGLNGDILVWNPVLEDAFELSSMGIRVDADTLKHQLALTGDEDRLELEWHQALLRGEMPQTIGGGIGQSRLTMLLLQLPH
IGQVQAGVWPAAVRESVPSLL
>Protein_Beta
ARNDCEQGHILKMFPSTWYV
>Protein_Gamma
MKTIALIVERQGHILKMFPNDCEQGSTLQIAPKNDCEQG
```

Execution example:

```
input: filename = "myfile.fasta" domains = ["QRQI", "LPDAQF"]
output: ["Protein_Alpha"]

input: filename = "myfile.fasta" domains = ["KMFP"]
output: ['Protein_Beta', 'Protein_Gamma']
```

```python
HEADERSTART = '>'

def getSequencesWithDomains(filename, domains):
    res = []
    try:
        with open(filename, "r") as filein:
            # number of domains
            num = len(domains)
            # list of sequences to be returned
            #read the header
            line = filein.readline().strip()
            while line and line[0] == HEADERSTART:
                seqname = line[1:]  #name of the sequence
                #read the entire sequence 
                seq = ""
                line = filein.readline().strip()
                while line and line[0] != HEADERSTART:
                    seq += line
                    line = filein.readline().strip()
                # the sequence is concluded
                # check if all domains are in
                allin = domains[0] in seq
                d = 1
                while allin and d < num:
                    if not domains[d] in seq:
                        allin = False
                    else:
                        d += 1
                if allin:
                    res.append(seqname)
            # no more lines
    except FileNotFoundError:
        print(f"problems accessing file {filename}")
    return res
```

::: 