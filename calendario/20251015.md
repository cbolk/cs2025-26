---
exe-start: 8
exepro-start: 13
---

# Python: control statements & strings

+ `for` statement 
+ strings

### Details

**`for`**

```python
for target in <collection>:
	statements
```

+ `range(_from_, _to_, _step_)`

+ strings
	- unmutable
	- index to access the individual items and `[]`
	- slices to access subsets of adjacent elements `[from:to]`
	- empty string `""`
	- methods

## Exercises in class

::: exefatti
Write a Python program that receives in input two positive integers, `fromval` and `toval` with `fromval` smaller than `toval`. The program computes and displays all prime numbers included in the interval, boundaries included. 

```py
fromval = int(input())
toval = int(input())
# for each number in my interval
val = fromval
while val <= toval:
	# compute if it is a prime number
	# val contains the value we have to verify 
	if val == 1:
		isprime = False
	else:
		isprime = True
		div = 2
		while div < val and (isprime == True):
			rem = val % div
			if rem == 0:
				isprime = False
			else:
				div += 1
	# if it is a prime number
	if isprime == True:		# if isprime:
		# display it
		print(val)
	val += 1	# next number to be processed
#end
```

[file](../codice/08.primeinterval.1.c)


Improving algorithm for prime computation.

```py
fromval = int(input())
toval = int(input())
# for each number in my interval
val = fromval
while val <= toval:
	# compute if it is a prime number
	# val contains the value we have to verify 
	if val == 1 or (val % 2 == 0 and val != 2) :
		isprime = False
	else:
		isprime = True
		div = 3
		while div*div < val and (isprime == True):
			rem = val % div
			if rem == 0:
				isprime = False
			else:
				div += 2	# next ODD number to be processed
	# if it is a prime number
	if isprime == True:		# if isprime:
		# display it
		print(val)
	val += 1	
#end
```

[file](../codice/08.primeinterval.2.c)

:::

::: exefatti
Write a python program that receives in input a strictly positive integer and computes and displays the highest number such that its square value is smaller or equal to the input.

```py
val = int(input())

# check all values such that their square is smaller than val
if val == 1:
	sq = 1
else:
	sq = 1
	while sq * sq < val:
		sq += 1
	sq -= 1
```

[file](../codice/09.closestrootofsquare.1.py)


Revised version, refactoring the `if` content.

```py
val = int(input())

# check all values such that their square is smaller than val
sq = 1
if val > 1:
	while sq * sq < val:
		sq += 1
	sq -= 1

```

[file](../codice/09.closestrootofsquare.py)

:::


::: exefatti
Write a Python program that accepts in input a string and a character and counts and displays the number of times the specified character appears in the string.

```py
seq = input()
ch = input()

count = 0
for el in seq:
	if el == ch:
		count += 1

print(count)
```

[file](../codice/10.countcharinseq.py)


It is not so interesting in this case to access the elements by position, `seq[i]` because the position is not relevant, moreover to use this kind of access it is necessary to compute the length of the string, which has a cost. See the code below.

```py
seq = input()
ch = input()

size = len(seq)
count = 0
for i in range(0, size):
	if seq[i] == ch:
		count += 1

print(count)
```

This does the same thing as the following code, even though we don’t write it that way. Built-in methods like `len()` are worth using because:
i) they’re simple, efficient, and already implemented in the best possible way — so there’s no need to reinvent them; and
ii) we should still know what happens behind the scenes and what performance costs their use might have. 

```py
seq = input()
ch = input()

# compute the length of the string
size = 0
for el in seq:
	size += 1

count = 0
for i in range(0, size):
	if seq[i] == ch:
		count += 1

print(count)
```

The goal of the problem is to practise access to the elements of a string in a proper way, therefore the solution below is not of interest. This statement can be used in a different situation when the goal of the problem is to exercise something else.

```py
seq = input()
ch = input()

# compute the length of the string

count = seq.count(ch)

print(count)
```

::: 


::: exefatti
Write a Python program that takes a string as input and two characters `oldc` and `newc` and **creates** a new string. The new string should contain the same content as the original input, except that every occurrence of character `oldc` is replaced by `newc`. The program displays the newly created string. Example:

```bash
"this is a test to check if my program works properly" "e" "x"
"this is a txst to chxck if my program works propxrly"
```

```python
seq = input()
oldc = input()
newc = input()

newseq = ""
for c in seq:
	if c == oldc:
		newseq = newseq + newc
	else:
		newseq = newseq + c

print(newseq)
```

[file](../codice/11.findreplacestring.1.py)


```python
seq = input()
oldc = input()
newc = input()

newseq = ""
for c in seq:
	if c == oldc:
		addch = newc
	else:
		addch = c
	newseq = newseq + addch

print(newseq)
```

[file](../codice/11.findreplacestring.2.py)

::: 


## Proposed exercises

Refrain from using string built-in methods to solve these problems, to practise algorithms and solving strategy.

::: exepro

Write a Python program that receives in input a string a displays True if the string is a palindrome, False otherwise.

:::

::: exepro
Write a program that accepts in input a string and computes and displays True
if it is a palindromic phrase (read from left to right or right to left is
the same if ignoring spaces and punctuation), False otherwise.

```bash
input: A man, a plan, a canal, Panama
output: 1
input: Was it a car or a cat I saw?
output: 1
input: Was it a cat or a car I saw?
output: 0
```

:::

::: exepro
Write a Python program that receives a string as input. The program creates a new string in which letters in even positions are uppercase, and letters in odd positions are lowercase. Non-alphabetical characters (spaces, punctuation, numbers) must be kept unchanged. The program then displays the new string.

You can use the `.upper()` and `.lower()` methods to convert a string (or a character) into upper case or lowercase, respectively.

```python
seq = input()

# Initialize an empty string to build the result
result = ""

# Set a counter to distinguish odd and even positions
index = 0
# for each element in the string
for ch in seq:
    if index % 2 == 0:  #even
        result = result + ch.upper()
    else: # Odd position : lowercase
        result = result + ch.lower()
    index += 1

print(result)
```

[file](../codice/90.camelstring.py)

:::


::: exepro

Write a program in Python that reads a string. For each character `car` in the sequence, starting from the last character and moving backward to the first, the program displays the character `car`, followed by the number of times it appears consecutively at that point in the string. As an example:

```bash 
input: zzbbbddbbbbhhhhhzzzz
output: z4h5b4d2b3z2
```

```python
seq = input()

size = len(seq)
i = size - 1  # Start from the last character
result = ""     # To build the final output

# Process characters from the end to the beginning
while i >= 0:
    ch = seq[i]
    count = 1
    i -= 1

    # Count how many times the same character repeats consecutively
    while i >= 0 and seq[i] == ch:
        count += 1
        i -= 1

    # convert integer into a string
    count_str = str(count)

    # Build result string
    result = result + ch + count_str

print(result)
```

[file](../codice/90.compressstringrev.py)

:::

::: exepro

Write a Python program that receives in input a string that includes a sentence. The program counts:

+ the number of words 
+ the number of alphabetical characters in the sentence

For instance: 

```bash
input: "This is a test string, to evaluate the program I have written."
output: 12 49
```

```python
sentence = input()

# Initialize counters
word_count = 0
letter_count = 0

in_word = False  # Tracks if we are currently inside a word
# Iterate through each character in the sentence
for ch in sentence:
    # Count alphabetic characters (A–Z, a–z)
    if ('A' <= ch <= 'Z') or ('a' <= ch <= 'z'):
        letter_count += 1
        # If we find a letter and we are not already in a word, it's a new word
        if not in_word:
            word_count += 1
            in_word = True
    else:
        # Any non-letter character ends the current word
        in_word = False

# Display the results
print(word_count, letter_count)
```

[file](../codice/90.analysesentence.py)

:::
