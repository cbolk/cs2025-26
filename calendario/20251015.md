---
exe-start: 8
exepro-start: 13
---

# Python: control statements & strings

+ `for` statement 
+ strings

### Details

**`for`**

```python
for target in <collection>:
	statements
```

+ `range(_from_, _to_, _step_)`

+ strings
	- unmutable
	- index to access the individual items and `[]`
	- slices to access subsets of adjacent elements `[from:to]`
	- empty string `""`
	- methods

## Exercises in class

::: exefatti
Write a Python program that receives in input two positive integers, `fromval` and `toval` with `fromval` smaller than `toval`. The program computes and displays all prime numbers included in the interval, boundaries included. 

```python
fromval = int(input())
toval = int(input())
# for each number in my interval
val = fromval
while val <= toval:
	# compute if it is a prime number
	# val contains the value we have to verify 
	if val == 1:
		isprime = False
	else:
		isprime = True
		div = 2
		while div < val and (isprime == True):
			rem = val % div
			if rem == 0:
				isprime = False
			else:
				div += 1
	# if it is a prime number
	if isprime == True:		# if isprime:
		# display it
		print(val)
	val += 1	# next number to be processed
#end
```

[file](../codice/08.primeinterval.1.c)


Improving algorithm for prime computation.

```python
fromval = int(input())
toval = int(input())
# for each number in my interval
val = fromval
while val <= toval:
	# compute if it is a prime number
	# val contains the value we have to verify 
	if val == 1 or (val % 2 == 0 and val != 2) :
		isprime = False
	else:
		isprime = True
		div = 3
		while div*div < val and (isprime == True):
			rem = val % div
			if rem == 0:
				isprime = False
			else:
				div += 2	# next ODD number to be processed
	# if it is a prime number
	if isprime == True:		# if isprime:
		# display it
		print(val)
	val += 1	
#end
```

[file](../codice/08.primeinterval.2.c)

:::

::: exefatti
Write a python program that receives in input a strictly positive integer and computes and displays the highest number such that its square value is smaller or equal to the input.

```python
val = int(input())

# check all values such that their square is smaller than val
if val == 1:
	sq = 1
else:
	sq = 1
	while sq * sq < val:
		sq += 1
	sq -= 1
```

[file](../codice/09.closestrootofsquare.1.py)


Revised version, refactoring the `if` content.

```python
val = int(input())

# check all values such that their square is smaller than val
sq = 1
if val > 1:
	while sq * sq < val:
		sq += 1
	sq -= 1

```

[file](../codice/09.closestrootofsquare.py)

:::


::: exefatti
Write a Python program that accepts in input a string and a character and counts and displays the number of times the specified character appears in the string.

```python
seq = input()
ch = input()

count = 0
for el in seq:
	if el == ch:
		count += 1

print(count)
```

[file](../codice/10.countcharinseq.py)


> It is not so interesting in this case to access the elements by position, `seq[i]` because the position is not relevant, moreover to use this kind of access it is necessary to compute the length of the string, which has a cost. See the code below.

```py
seq = input()
ch = input()

size = len(seq)
count = 0
for i in range(0, size):
	if seq[i] == ch:
		count += 1

print(count)
```

> This does the same thing as the following code, even though we don’t write it that way. Built-in methods like `len()` are worth using because:
> i) they’re simple, efficient, and already implemented in the best possible way — so there’s no need to reinvent them; and
> ii) we should still know what happens behind the scenes and what performance costs their use might have. 

```py
seq = input()
ch = input()

# compute the length of the string
size = 0
for el in seq:
	size += 1

count = 0
for i in range(0, size):
	if seq[i] == ch:
		count += 1

print(count)
```

The goal of the problem is to practise access to the elements of a string in a proper way, therefore the solution below is not of interest. This statement can be used in a different situation when the goal of the problem is to exercise something else.

```py
seq = input()
ch = input()

# compute the length of the string

count = seq.count(ch)

print(count)
```

::: 

## Proposed exercises
::: exepro
Write a Python program that receives in input a sequence of 35 integers and it computes and displays minimum, maximum and average values of those values.

```python
# CONSTANT / ARBITRARY ASPECTS OF THE SOLUTION
NVAL = 35

val = int(input())
minv = val
maxv = tot = val

i = 1
while i < NVAL:
	val = int(input())
	tot += val
	if val >= maxv:
		maxv = val
	elif val < minv:
		minv = val
	i += 1

avgv = tot / NVAL
print(minv, maxv, avgv)
```

[file](../codice/90.minmaxavseq.py)

:::


::: exepro

Write a Python program that receives in input a sequence of integers of an a-priori unknown length. When the user inserts `0` the sequence is considered terminated and `0` is not part of the dataset. The program computes and displays minimum, maximum and average values of those values. The user will surely insert a valid integer before the terminal `0`.


```python
# CONSTANT / ARBITRARY ASPECTS OF THE SOLUTION
STOP = 0

val = int(input())
minv = val
maxv = tot = val
nval = 1

val = int(input())
while val != STOP:
	tot += val
	if val > maxv:
		maxv = val
	elif val < minv:
		minv = val
	nval += 1
	val = int(input())

avgv = tot / nval
print(minv, maxv, avgv)
```

[file](../codice/90.minmaxavgseq.py)

:::

::: exepro
Write a Python program that repeatedly asks the user to enter integers one at a time.
The input ends when the user enters `0` (which is not part of the data set).
The program counts:

+ the number of even numbers entered,
+ the number of odd numbers entered, and
+ the total count of numbers entered

```python
STOP = 0

count_e = 0
count_o = 0

n = int(input())
while n != STOP:
	if n % 2 == 0:
		count_e += 1
	else:
		count_o += 1
	n = int(input())

count = count_e + count_o
print(count_e, count_o, count)
```

[file](../codice/90.countevenodd.py)

:::


::: exepro
Write a Python program that, given to integers received from the user in increasing order, finds and displays all the numbers **between** the two (boundary excluded) that only contain even digits.

```python
BASE = 10

start = int(input())
end = int(input())

if (start+1 % 2) == 1:	/* if it is odd, it does not have all even digits */
	start += 1

i = start
while i < end:
	num = i
	all_even = True
	while (num > 0) and all_even:
		digit = num % BASE
		if digit % 2 != 0:
			all_even = False
		num //= BASE
	if all_even:
		print(i)
	i += 2
```

[file](../codice/90.fromtoeven.1.py)


> Version with `for` statement

```python
BASE = 10

start = int(input())
end = int(input())

if (start+1 % 2) == 1:	/* if it is odd, it does not have all even digits */
	start += 1

for i in range(start, end, 2):
	num = i
	all_even = True
	while (num > 0) and all_even:
		digit = num % BASE
		if digit % 2 != 0:
			all_even = False
		num //= BASE
	if all_even:
		print(i)
```

[file](../codice/90.fromtoeven.2.py)

:::


::: exepro
Write a Python program that receives in input 4 integer values, `start1`, `end1`, `start2`, `end2`, such that it is surely `start1 < end1` and `start2 < end2`. These two pairs identify the starting and ending points of two segments. The program computes if the segments overlap and if one is completely included in the other. The program displays to digits: the first digit is 1 when segments overlap, 0 otherwise; the second digit is 1 when one segments is completely included in the other, 0 otherwise.
Examples:

```bash
input: 5 7 7 9 
output: 10 (segments overlap on 7, no inclusion)
input: 2 8 3 7 
output: 11 (segments overlap, 3-7 is included in 2-8)
input: 4 12 1 12 
output: 11 (segments overlap, 1-12 is included in 4-12)
input: 4 11 23 27 
output: 00 (segments do not overlap, no inclusion)
```


:::