---
exe-start: 42
exepro-start: 55
---

# Python: files and error handling

## Exercises in class

::: exefatti

Write a Python function that receives in input the name of a file containing integer values (one per line) and returns the list of values included in the file without repetitions.

```Python
def loadData(fname):
	lst = []
	#open the file
	f = open(fname, "r")
	# for each line in the file
	for line in f:
		# gather the number
		num = int(line.strip())
		# if it is not already in the list
		if not num in lst:
			# add it
			lst.append(num)
	#close the file
	f.close()
	return lst

def loadData_v2(fname):
	lst = []
	#open the file
	with open(fname, "r") as f:
	    # for each line in the file
        line = f.readline()
        while line != "":
            num = int(line.strip())
            # if it is not already in the list
            if not num in lst:
                # add it
                lst.append(num)
            line = f.readline()
	return lst
```

[file](../codice/42.file.loadintnorep.1.py)

[file](../codice/42.file.loadintnorep.2.py)

Version loading the entire file in memory (as a list): it is efficient in terms of processing with respect to reading one line at a time, however it incurs in a memory overhead ... the tradeoff depends on the size of the file.

```python
def loadData(fname):
    lst = []
    #open the file
    with open(fname, "r") as f:
        # for each line in the file
        lines = f.readlines()

        for elem in lines:
            num = int(elem.strip())
            # if it is not already in the list
            if not num in lst:
                # add it
                lst.append(num)

    return lst
```

[file](../codice/42.file.loadintnorep.3.py)

:::

::: exefatti

Write a Python program that accepts a filename in input and returns True if the file exists, is readable, and contains at least one character.

```Python
def check_file(fname):
    try:
        # Try to open the file in read mode
        with open(fname, "r"):
            content = f.read(1)  # Read just one character
            return len(content) > 0
    except:
        # If any error occurs (file not found, no permission, etc.)
        return False

```

[file](../codice/43.file.checkfile.py)


:::


::: exefatti

A text file contains a sequence of strings consisting of the repetition of the `'*'` character, separated by one or more spaces and newlines. Each string represents an integer value encoded in the unary code. For instance, if the file content is

```
******* ****** ***
*** ******************
```

the file contains values 7, 6, 3, 3 and 18. Write a Python function that receives in input the name of the file and computes and returns the list of values included in the file and their mean value. It also displays the mean value rounded to the floor in the same unary code. 

Still referring to the example, the function returns `[7, 6, 3, 3, 18]` and `7.4` and displays `*******`. 



```Python
SYMBOL = '*'

def process_unary_file(filename):
    """
    Reads a file containing unary-encoded integers (as '*' repeated),
    separated by spaces and newlines. Returns a list of integers and their mean,
    and prints the mean rounded down in unary code.
    """
    values = []
    mean_value = 0
    try:
        # Open the file and read all content in one long string ("\n" included)
        with open(filename, 'r') as f:
            content = f.read()

        # Split by whitespace (spaces, tabs, newlines)
        tokens = content.split()

        # Convert each token to its length (unary decoding)
        totvalues = 0
        for token in tokens:
            value = len(token)
            totvalues += value
            values.append(value)

        numvalues = len(values)
        # Compute mean
        if numvalues > 0:
            mean_value = totvalues / numvalues

        # Floor the mean and display in unary
        mean_floor = int(mean_value)
        print(SYMBOL * mean_floor)

    except FileNotFoundError:
        print(f"Error: File {filename} not found.")

    except Exception as e:
        print("Error:", e)

    return values, mean_value

```

[file](../codice/44.unarytoint.py)

:::


::: exefatti

Write a Python program that asks the user to input a word in the English language and computes and displays all proper words that are anagrams of the input, also displaying the total number. 
File "dictionary.en.txt" contains the list of all proper words.

For example:
```
input: trace
output: caret
cater
cerat
crate
creat
ecart
react
recta
8
```

```Python
DICTNAME = "dictionary.txt"

def find_anagrams(word, dicFilename):
    """
    Finds all proper words in dictionary.txt that are anagrams of the input. 
    """
    anagrams = []
    try:
        # Read dictionary file line by line
        dictionary = []
        with open(dicFilename, "r") as f:
            for line in f:
                line = line.strip().lower()
                if line != "":
                    dictionary.append(line)

        # Prepare letter-count dictionary for input word
        input_letters = {}
        for ch in word:
            if ch in input_letters:
                input_letters[ch] += 1
            else:
                input_letters[ch] = 1

        # Find anagrams
        for w in dictionary:
            if w != word:  # skip the same word
                # I would compare lengths, since in python it has a single access cost
                # I would not do it in another language
                # Count letters in w
                w_letters = {}
                for ch in w:
                    if ch in w_letters:
                        w_letters[ch] += 1
                    else:
                        w_letters[ch] = 1

                # Compare dictionaries
                if w_letters == input_letters:
                    anagrams.append(w)
    except FileNotFoundError:
        print("Error: dictionary.txt not found.")
    except Exception as e:
        print("Error:", e)
    return anagrams


# ---- MAIN FLOW -----

word = input("Enter a word: ").strip().lower()
anagrams = find_anagrams(word, DICTNAME)

# Display results
for a in anagrams:
    print(a)
print(len(anagrams))
```

[file](../codice/45.anagramsofword.1.py)


Alternative version for computing anagrams using counters. 

```Python
DICTNAME = "dictionary.en.txt"
ASCIICHARS_SIZE = 256   # number of existing ASCII characters

def find_anagrams(word, dicFilename):
    anagrams = []
    try:
        with open(dicFilename) as fin:
            # set up counter for the given word -- kept for the entire computation
            counters_w = [0] * ASCIICHARS_SIZE
            for c in word:
                counters_w[ord(c)] += 1
            # I will compare against it the counters I get for each dictionary word
            for line in fin:
                word_dic = line.strip().lower()
                if word != word_dic:
                    #in python is a single not expensive access
                    if len(word) == len(word_dic):
                        #I compute the counters for the dictionary word
                        counters_wd = [0] * ASCIICHARS_SIZE
                        for c in word_dic:
                            counters_wd[ord(c)] += 1
                            # anticipate check ... is it sustainable/worth it?
                            if counters_wd[ord(c)] > counters_w[ord(c)]:
                                break
                        if counters_wd == counters_w:
                            anagrams.append(word_dic)

    except FileNotFoundError:
        print(f"Error: {dicFilename} not found.")
    except Exception as e:
        print("Error:", e)

    return anagrams

# ---- MAIN FLOW -----

word = input("Enter a word: ").strip().lower()
anagrams = find_anagrams(word, DICTNAME)

# Display results
for a in anagrams:
    print(a)
print(len(anagrams))
```

[file](../codice/45.anagramsofword.2.py)


Alternative version using a function to check if two words are anagrams. It is not convenient here because it analyses the given word every time. Thus, given the mission of the program, a function is ineffective.

```Python
DICTNAME = "dictionary.en.txt"
ASCIICHARS_SIZE = 256   # number of existing ASCII characters

def find_anagrams(word, dicFilename):
    anagrams = []
    try:
        with open(dicFilename) as fin:
            # set up counter for the given word -- kept for the entire computation
            counters_w = [0] * ASCIICHARS_SIZE
            for c in word:
                counters_w[ord(c)] += 1
            # I will compare against it the counters I get for each dictionary word
            for line in fin:
                word_dic = line.strip().lower()
                if word != word_dic:
                    #in python is a single not expensive access
                    if len(word) == len(word_dic):
                        #I compute the counters for the dictionary word
                        counters_wd = [0] * ASCIICHARS_SIZE
                        for c in word_dic:
                            counters_wd[ord(c)] += 1
                            # anticipate check ... is it sustainable/worth it?
                            if counters_wd[ord(c)] > counters_w[ord(c)]:
                                break
                        if counters_wd == counters_w:
                            anagrams.append(word_dic)

    except FileNotFoundError:
        print(f"Error: {dicFilename} not found.")
    except Exception as e:
        print("Error:", e)

    return anagrams

# ---- MAIN FLOW -----

word = input("Enter a word: ").strip().lower()
anagrams = find_anagrams(word, DICTNAME)

# Display results
for a in anagrams:
    print(a)
print(len(anagrams))
```

[file](../codice/45.anagramsofword.3.py)

:::


::: exefatti

A CSV file named `patients.csv` contains information about patients in the following format:
```
name,weight,height
Alice,68,1.65
Bob,85,1.80
Carol,54,1.60
```
Write a Python program that:
+ Reads the file `patients.csv`.
+ Computes the BMI (Body Mass Index) for each patient using the formula: `BMI = weight/(height)^2`
+ Computes and displays each patient's name and BMI rounded to one decimal place
+ Computes and displays the average BMI of all patients.


```python
# solution with csv library
import csv

FNAME = "patients.csv"

def compute_bmi_from_csv(filename):
    """
    Reads a CSV file with patient data and computes BMI for each patient.
    Returns a dictionary {name: BMI}.
    """
    bmi_values = {}
    try:
        with open(filename, newline='') as f:
            reader = csv.reader(f)

            # Read header
            header = next(reader)

            # Process rows
            for row in reader:
                name = row[0].strip()
                weight = float(row[1])
                height = float(row[2])
                bmi = weight / (height ** 2)
                bmi_values[name] = bmi

    except FileNotFoundError:
        print("Error: File not found.")

    except Exception as e:
        print("Error:", e)

    return bmi_values


# ---- MAIN SCRIPT -----

bmi_values = compute_bmi_from_csv(FNAME)

if len(bmi_values) > 0:
    # Display each BMI
    for name in bmi_values:
        print(name, "-", round(bmi_values[name], 1))

    # Compute and display average BMI
    avg_bmi = sum(bmi_values.values()) / len(bmi_values)
    print("Average BMI:", round(avg_bmi, 1))
else:
    print("No valid data found.")

```

[file](../codice/46.file.patients.csv.py)

Solution without `csv` library.

```python
FNAME = "patients.csv"

def compute_bmi_from_csv(filename):
    """
    Reads a CSV file with patient data and computes BMI for each patient.
    Returns a dictionary {name: BMI}.
    """
    bmi_values = {}
    try:
        with open(filename, "r") as f:
            lines = f.readlines()

        # Skip header (first line)
        index = 1  # start from second line
        total_lines = len(lines)

        while index < total_lines:
            line = lines[index].strip()
            parts = line.split(",")

            name = parts[0].strip()
            weight = float(parts[1])
            height = float(parts[2])
            bmi = weight / (height ** 2)
            bmi_values[name] = bmi

            index += 1  # move to next line

    except FileNotFoundError:
        print("Error: File not found.")
    except Exception as e:
        print("Error:", e)

    return bmi_values

# ---- MAIN SCRIPT -----

bmi_values = compute_bmi_from_csv("patients.csv")

if len(bmi_values) > 0:
    # Display each BMI
    for name in bmi_values:
        print(name, "-", round(bmi_values[name], 1))

    # Compute and display average BMI
    avg_bmi = sum(bmi_values.values()) / len(bmi_values)
    print("Average BMI:", round(avg_bmi, 1))
else:
    print("No valid data found.")
```

[file](../codice/46.file.patients.py)

:::


::: exefatti

Write a Python program that:

* Initializes an empty Tic Tac Toe board.
* Asks each player (Player 1 = X, Player 2 = O) to enter their move as a **coordinate in the format `row,col`**, where both numbers range from **1 to 3.**
* Updates the board with the move, and prints back whether move is valid, invalid or whether thereâ€™s a player who wins the game.

```Python

NUM_MOVES = 9
NO_WINNER = 0

def get_move(player):
    move = input(f"Player {player} enter your move (row,col): ")
    parts = move.split(',')
    row = int(parts[0].strip()) - 1
    col = int(parts[1].strip()) - 1
    while not(0 <= row < 3 and 0 <= col < 3):
        print("Row and column must be between 1 and 3.")
        move = input(f"Player {player} enter your move (row,col): ")
        parts = move.split(',')
        row = int(parts[0].strip()) - 1
        col = int(parts[1].strip()) - 1
    return row, col
    
    
# ---- MAIN SCRIPT ------

board = [[0,0,0],[0,0,0],[0,0,0]]

current_player = 1
count_moves = 0
winner = NO_WINNER

row, col = get_move(current_player)
valid_move = (board[row][col] == 0) 
while not valid_move:
    print("Invalid move: cell already taken. Try again.\n")
    row, col = get_move(current_player)
    valid_move = (board[row][col] == 0) 

board[row][col] = player
count_moves += 1
winner = check_winner(board)
while count_moves < NUM_MOVES and winner == NO_WINNER:
    print("Valid mode, no winner, change player")
    row, col = get_move(current_player)
    valid_move = (board[row][col] == 0) # check_move_validity(row,col)
    if valid_move:
        board[row][col] = player #update_board(board, row, col, current_player)
        count_moves += 1
        winner = check_winner(board)
        # changing player -- eventually not useful
        if current_player == 1:
            current_player = 2
        else:
            current_player = 1
        # current_player = (current_player % 2) + 1

        # Check winner
    else:
        print("Invalid move: cell already taken. Try again.\n")

if winner != 0:
    print(f"Player {winner} wins the game!")
else:
    print("Game over: it's a draw.")


```



::: exefatti
Write Python functions to deal with Tic Tac Toe Leaderboard by updating a file `leaderboard.csv` that contains the number of wins for each player in the format:
```
player,wins
Alice,2
Bob,1
```

```Python

def load_leaderboard(filename):
    leaderboard = {}
    try:
        with open(filename, "r") as f:
            lines = f.readlines()

        index = 1  # skip header

        while index < len(lines):
            line = lines[index].strip()
            parts = line.split(",")

            name = parts[0].strip()
            wins = int(parts[1])
            leaderboard[name] = wins

            index += 1

    except FileNotFoundError:
        print("Leaderboard file not found. Starting new leaderboard.")
    return leaderboard

def update_leaderboard(filename, leaderboard, winner):
    if winner in leaderboard:
        leaderboard[winner] += 1
    else:
        leaderboard[winner] = 1

    try:
        with open(filename, "w") as f:
            f.write("player,wins\n")  # header
            for name in leaderboard:
                f.write(name + "," + str(leaderboard[name]) + "\n")
    except Exception as e:
        print("Error writing leaderboard:", e)


```



::: exefatti

Write Python functions to display leaderboard winners ordered by number of games won

```
player,wins
Alice,12
Bob,10
Ryan,3
```

```Python
def display_leaderboard(leaderboard):
    ordered_players = []  

    for player in leaderboard:
        # Find position to insert player
        pos = 0
        while pos < len(ordered_players) and leaderboard[player] < leaderboard[ordered_players[pos]]:
            pos += 1
        ordered_players.insert(pos, player)

    # Print in decreasung order
    print("\nLeaderboard:")
    for name in ordered_players:
        print(name, "-", leaderboard[name])
```