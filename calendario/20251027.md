---
exe-start: 19
exepro-start: 28
---

# Exercises: data structures


## Solved exercises

::: exefatti

Write a Python program that reads a sequence of strings entered by the user, one at a time. The total number of strings is unknown, and the input process should stop when the user types the word "stop", which must not be included in the count. After collecting the sequence, the program should calculate and display how many of the entered strings have an even number of characters, how many have an odd number of characters, and the total number of strings entered. 


```python
STOPWORD = "stop"

even_count = 0
odd_count = 0

user_word = input("Enter a string (type 'stop' to finish): ")
user_word = user_word.strip()
while user_word != STOPWORD:
    # check string len
    if len(user_word) % 2 == 0:
	    even_count += 1
	else:
	    odd_count += 1
    user_word = input("Enter a string (type 'stop' to finish): ")
    user_word = user_word.strip()
        
# display
print("Total strings: ", even_count+odd_count)
print("Even-length strings: ", even_count)
print("Odd-length strings: ", odd_count)
```

[file](../codice/19.evenoddstrings.nothing.py)


Variant: The program must also display all words with an even number of characters and all words with an odd number of characters separately.

```python
# Solution with two lists
STOPWORD = "stop"

odd_sequence = [] 
even_sequence = []      

user_word = input("Enter a string (type 'stop' to finish): ")
user_word = user_word.strip()
while user_word != STOPWORD:    
    if len(user_word) % 2 == 0:
        even_sequence.append(user_word)
    else:
        odd_sequence.append(user_word)
    user_word = input("Enter a string (type 'stop' to finish): ")
    user_word = user_word.strip()
        
# display
print("Total strings:", len(odd_sequence) + len(even_sequence))
print("Total even-length strings:", len(even_sequence))
for word in even_sequence:
	print(word)
print("Total odd-length strings:", len(odd_sequence))
for word in odd_sequence:
    print(word)

```

[file](../codice/19.evenoddstrings.lists.py)


Variant: The program should only consider unique words, and the order of the words does not matter.

```python
# Solution with two sets
STOPWORD = "stop"

odd_words = set()
even_words = set()

user_word = input("Enter a string (type 'stop' to finish): ")
user_word = user_word.strip()
while user_word != STOPWORD:    
    if len(user_word) % 2 == 0:
        even_words.add(user_word)
    else:
        odd_words.add(user_word)
    user_word = input("Enter a string (type 'stop' to finish): ")
    user_word = user_word.strip()

# Display results
print("Total unique strings:", len(odd_words) + len(even_words))
print("Total even-length unique strings:", len(even_words))
for word in even_words:
    print(word)
print("Total odd-length unique strings:", len(odd_words))
for word in odd_words:
    print(word)

```

[file](../codice/19.evenoddstrings.sets.py)

::: 

::: exefatti

Write a Python program that receives a sequence of words, one of per line, until the user inserts an empty line. The program computes and displays the word that appears more often. There is a single word that matches this requirement.

```bash
apple
orange
banana
apple
orange
apple
apple
orange
banana
apple
orange
apple

apple 6
```


```python
STOP = ""

frequencies = {}

word = input()
if word != STOP:
    maxfword = word
    maxfreq = 1
    frequencies[word] = 1
    word = input()
    while word != STOP:
        #increment frequencies
        if word in frequencies.keys():
            num = frequencies[word] + 1
        else:
            num = 1
        frequencies[word] = num
        if num > maxfreq:
            maxfword = word
            maxfreq = num
        #next word
        word = input()
else:
    maxfword = ""
    maxfreq = 0
print(maxfword, maxfreq)
```

[file](../codice/20.mostfrequentword.dic.py)


```python
STOP = ""

frequencies = []

word = input()
if word != STOP:
    maxfword = word
    maxfreq = 1
    frequencies.append([word, 1])
    word = input()
    while word != STOP:
        found = False
        for pair in frequencies:
            if pair[0] == word:
                found = True
                pair[1] = pair[1]+1
                break
        if found:
            num = pair[1]
        else:
            num = 1
            frequencies.append([word, num])

        if num > maxfreq:
            maxfword = word
            maxfreq = num
        #next word
        word = input()
else:
    maxfword = ""
    maxfreq = 0
print(maxfword, maxfreq)
```

[file](../codice/20.mostfrequentword.list.py)

:::

::: exefatti

Write a Python program that reads a sequence of 10 integers entered by the user and modifies the sequence by removing all adjacent elements that have consecutive values (i.e., numbers that differ by 1), while preserving the original order of the remaining elements. For example, if the input is:

```bash
4, 5, 6, 2, 7, 3, 2, 1, 2, 5
```
output should be: 
```bash
2, 7, 5

```

```python
NVAL = 10

num_sequence = []
valid = []
for i in range(NVAL):
    n = int(input(f"Insert number {i+1}: "))
    num_sequence.append(n)
    valid.append(True)

# Determine which indexes to remove
i = 0
while i < NVAL - 1:  # must stop at NVAL-1 to avoid index error
     # If two consecutive numbers differ by 1, must be removed both
    if abs(num_sequence[i] - num_sequence[i + 1]) == 1:
        # Without abs: if (num_sequence[i] + 1 == num_sequence[i + 1]) or (num_sequence[i] - 1 == num_sequence[i + 1]):
        valid[i] = False
        valid[i + 1] = False
    i += 1

# Remove invalid numbers
i = 0
while i < NVAL:
    if not valid[i]:
        num_sequence.pop(i)
        valid.pop(i)
    else:
        i += 1

print("Output:", num_sequence)

```

[file](../codice/21.removeadjacentconsecutives.1.py)

Alternative solution without using a new list

```python
NVAL = 10

num_sequence = []
valid = []
for i in range(NVAL):
    n = int(input(f"Insert number {i+1}: "))
    num_sequence.append(n)
    valid.append(True)

# Determine which indexes to remove
i = 0
while i < NVAL - 1:  # must stop at NVAL-1 to avoid index error
     # If two consecutive numbers differ by 1, must be removed both
    if abs(num_sequence[i] - num_sequence[i + 1]) == 1:
        valid[i] = False
        valid[i + 1] = False
    i += 1

# Add valid number 
valid_sequence = []
i = 0
while i < NVAL:
    if valid[i]:
        valid_sequence.append(num_sequence[i])
    i += 1

print("Output:", valid_sequence)

```

[file](../codice/21.removeadjacentconsecutives.2.py)

:::

## Proposed exercises


::: exepro

Write a Python program that receives a first collection of words by means of words on a single line in input, separated by a space, a second collection of words, again on a single line in input, separated by a space. The program computes and **creates a list of words that appear more than once in both lists**. For instance, consider the two lists in the example:

```bash
input: 
dog cat zebra bird horse cat penguin dog bird frog horse elephant ant cat wolf cat horse dog bird
wolf dog wolf frog cat frog penguin dog horse ant dolphin dog bird horse dolphin zebra dog dog
output: 
dog horse
```

```python
''' Version with lists as intermediate data structures. The limitation is that the intersection of the intermediate lists is performed manually, however the final requested output is the list, therefore the final output is ready.
'''

# first collection
seq1 = input().strip().split()
# second collection
seq2 = input().strip().split()

# create a list of words that appear more than once in the first list
dup_seq1 = []
# for every word in the list
pos = 0
for word in seq1:
    # if word has another entry in the rest of the list
    if word in seq1[pos+1:]:
        # if it has not been found yet (and added to the list of repeated words)
        if word not in dup_seq1:
            dup_seq1.append(word)
    pos += 1

# the same with the second collection
dup_seq2 = []
pos = 0
for word in seq2:
    # if word has another entry in the rest of the list
    if word in seq2[pos+1:]:
        # if it has not been found yet (and added to the list of repeated words)
        if word not in dup_seq2:
            dup_seq2.append(word)
    pos += 1

# the words common to both lists
common_rep_words = []
for word in dup_seq1:
    if word in dup_seq2:
        common_rep_words.append(word)

# display
for word in common_rep_words:
    print(word, end=" ")
print()
```

[file](../codice/90.commonrepwords.list.py)


```python
'''
Version with lists as intermediate data structures. The limitation is that the intersection of the intermediate lists is performed manually, however the final requested output is the list, therefore the final output is ready.
'''
# first collection
seq1 = input().strip().split()
# second collection
seq2 = input().strip().split()

# create set of words that appear more than once in the first list
# exploit set unique element property and later the intersection
dup_seq1 = set()
# for every word in the list
pos = 0
for word in seq1:
    # if word has another entry in the rest of the list
    if word in seq1[pos+1:]:
        dup_seq1.add(word)
    pos += 1

# the same with the second collection
dup_seq2 = set()
pos = 0
for word in seq2:
    # if word has another entry in the rest of the list
    if word in seq2[pos+1:]:
        # if it has not been found yet (and added to the list of repeated words)
        dup_seq2.add(word)
    pos += 1

# intersection of the words common to both sets
common_rep_words_set = dup_seq1.intersection(dup_seq2)
# or 
# common_rep_words_set = dup_seq2.intersection(dup_seq1)

common_rep_words = list(common_rep_words_set)

# display
for word in common_rep_words:
    print(word, end=" ")
print()

'''
**Note**: the output when using sets cannot be _controlled_, which means that if the request also has requirements such that "the words should be in the order they appear in one of the two lists", this cannot be achieved. 
'''
```

[file](../codice/90.commonrepwords.set.py)

:::

::: exepro

Write a program that receives as input a sequence of statements to update the quantity of medicines in storage. The program processes all statements and finally displays the medicines **available** in the storage and their quantity. **Assume that it will not occur that the the quantity of a medicine in the storage becomes negative.** Each statement is formed by three elements (separated by commas):
+ name of the medicine
+ add/remove
+ quantity (integer)

As an example, consider:

```bash
Aspirin,add,100
Tylenol,add,50
Aspirin,remove,30
Antibiotic,add,25
Tylenol,remove,50
Beta blockers,add,40
Aspirin,add,20
Syrup,add,15
Antibiotic,remove,5
Beta blockers,remove,5
Aspirin,add,20
Aspirin,add,10
Beta blockers,add,10


output:
Aspirin 120
Antibiotic 20
Beta blockers 45
Syrup 15
```

```python
SEP = ","
OPADD = "add"
OPDEL = "remove"

storage = {}

entry = input()
while entry != "":
    # get the entry
    info = entry.strip().split(SEP)
    # retrieve the quantity in the storage if there is already the medicine in the storage
    if info[0] in storage:
        qty = storage[info[0]]
    else:
        qty = 0
    if info[1] == OPADD:
        storage[info[0]] = qty + int(info[2].strip())
    else:
        storage[info[0]] = qty - int(info[2].strip())
    entry = input()

# acquisition is completed
for key, value in storage.items():
    if value > 0:   #only it has a quantity
        print(key, value)

```

[file](../codice/90.medicinestorage.py)


:::

::: exepro

Write a Python program that defines a set of magic words (for example, "cow", "pig", "chicken"). The user is asked to enter words one by one, trying to guess one of the magic words before reaching a predefined maximum number of attempts. If the user succeeds, display a success message along with the list of magic words. If the user fails, display only a failure message and a predefined hint.

```python
MAGIC_WORDS = set("cow", "pig", "chicken")  # set
HINT = "Hint: Try common farm animals."

# Set maximum number of attempts
MAX_ATTEMPS = 5

# Initialize variables
num_attempts = 0
guessed = False

# Ask the user to guess words
while attempts < MAX_ATTEMPS and not guessed:
    print("")
    user_word = input(f"Attempt {num_attempts + 1}/{MAX_ATTEMPS} - Enter a word: ")
    user_word = user_word.strip().lower()
    num_attempts = num_attempts + 1  # Increment attempts
    
    # Check if the word is in the magic set
    if user_word in MAGIC_WORDS:
        guessed = True
    else:
        print("Incorrect guess. Try again.")

# Display results
if guessed:
    print("Success! You guessed a magic word.")
    print("Magic words were: ", MAGIC_WORDS)
    print("Attempts used:", num_attempts)
else:
    print("Failure! You did not guess any magic word.")
    print(HINT)
```

[file](../codice/90.guess.set.1.py)


:::


::: exepro
Write a Python program that defines a set of magic words (for example, "cow", "pig", "chicken"). The user enters a sequence of words separated by commas (for example: "apple, python, banana, code"). The program counts how many words from the user's sequence are present in the magic set. If all the words in the magic set are guessed within the three allowed number of attempts, print a success message.

```python
MAGIC_WORDS = set("cow", "pig", "chicken")  # set
HINT = "Hint: Try common farm animals."

# Set maximum number of attempts
MAX_ATTEMPS = 5

# Initialize variables
num_attempts = 0
guessed = False

# Ask the user to guess words
while attempts < MAX_ATTEMPS and not guessed:
    print("")
    user_word = input(f"Attempt {num_attempts + 1}/{MAX_ATTEMPS} - Enter a word: ")
    user_word = user_word.strip().lower()
    num_attempts = num_attempts + 1  # Increment attempts
    
    # Check if the word is in the magic set
    if user_word in MAGIC_WORDS:
        guessed = True
    else:
        print("Incorrect guess. Try again.")

# Display results
if guessed:
    print("Success! You guessed a magic word.")
    print("Magic words were: ", MAGIC_WORDS)
    print("Attempts used:", num_attempts)
else:
    print("Failure! You did not guess any magic word.")
    print(HINT)
```

[file](../codice/90.guess.set.2.py)

:::

::: exepro
Write a Python program to manage a basic structure for storing students' grades. The program should first ask the user whether they want to perform one of two actions:
+ "insert": insert a new grade for a student
+ "average": calculate the average of all grades for a specific student

If the user chooses **insert**, the program should ask for the "student_id" and then the grade to add. If the student_id already exists, the new grade should be added to the existing list of grades; otherwise, a new entry should be created.

If the user chooses **average**, the program should ask again for the "student_id". If the student exists, the program should return the average of all grades for that student; otherwise, it should display an error message indicating that the student is missing.

The program ends the acquisition when the user introduces **stop**.

```python
# Initialize dictionary to store student grades
STOPWORD = "stop"
ADD = "insert"
AVG = "average"
grades = {}

action = input("Choose an action ('insert', 'average', 'stop'): ").strip().lower()
while action != STOPWORD:
    student_id = input("Enter student ID: ").strip()
    if action == ADD:
        grade = float(input("Enter grade: "))    
        # Insert or update grades
        if student_id not in grades:
            grades[student_id] = [grade] # add new student          
        else:
            grades[student_id].append(grade) # append new grade                
    elif action == AVG:
        if student_id in grades:
            student_grades = grades[student_id]
            student_avg = sum(student_grades) / len(student_grades)
            print(f"Average grade for student {student_id}: {student_avg}")
        else:
            print("Error: Student ID not found.")
    else:
        print("Invalid action. Please choose 'insert', 'average', or 'stop'.")
    action = input("Choose an action ('insert', 'average', 'stop'): ").strip().lower()
```

[file](../codice/90.studentsgrades.py)

:::


::: exepro

Write a Python that receives in input a string, a character `sep`, an integer `size`. The string contains a sequence of integer values, separated by the `sep` character. For instance, if the string contains `"3|-43|3|43|43|-32|32|1|2|3|4|5|-3|2|3|4|2|2|0|-11|-43|3|43|5|2|4|3|-32|3|2|1|2|3|4|5|-3|2|3|4|2|11|0|-11|0|4|2|8|5|9|10|3|7|0|7|8|2|6|1|93|4|10|10|9|2|3|0|1|6|2|11|5|2|5|0|5|2|1|-6|2|5|3|5|2|5|11|0|3|0|9|8|7|-43|-6|0|9|1|3|-3|-3|0|5|7|4|8|0|11|4|5|6|0|3|11|10|10|3|3|2|-11|-11|43|10|9"` the user would then specify `|` as the separator character. The program computes the `size` less frequent numbers. Example:

```bash
input:
3|-43|3|43|43|-32|32|1|2|3|4|5|-3|2|3|4|2|2|0|-11|-43|3|43|5|2|4|3|-32|3|2|1|2|3|4|5|
-3|2|3|4|2|11|0|-11|0|4|2|8|5|9|10|3|7|0|7|8|2|6|1|93|4|10|10|9|2|3|0|1|6|2|11|5|2|5|
0|5|2|1|-6|2|5|3|5|2|5|11|0|3|0|9|8|7|-43|-6|0|9|1|3|-3|-3|0|5|7|4|8|0|11|4|5|6|0|3|
11|10|10|3|3|2|-11|-11|43|10|9
| (separator)
4 (4 less frequent values)
output:
32
93
-32
-6
```

```python
seq = input().strip()
sep = input().strip()
size = int(input().strip())

values = seq.split(sep)
numbers = {}
for val in values:
    num = int(val)
    if val in numbers:
        numbers[val] += 1
    else:
        numbers[val] = 1

sorted_list = sorted(numbers.items(), key=lambda x: x[1])

for i in range(0, size):
    print(sorted_list[i][0])
```

[file](../codice/90.lessfreqvalues.py)

:::