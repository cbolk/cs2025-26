---
exe-start: 26
exepro-start: 20
---

# Python: sequences - data structures

+ lists

### Details

+ lists
	- mutable
	- index
	- slices
	- empty list `[]`


## Exercises in class

::: exefatti

**Q1**: What does this program do?

**Q2**: Is there any difference in the problems they solve?

```bash
in: narrative alternatives
out: True

in: stare alternatives
out: True

in: store alternatives
out: True
```

```python
seq = input()
longseq = input()

allfound = True
for elem in seq:
	if elem not in longseq:
		allfound = False
		break

print(allfound)
```

[file](../codice/12.selftest.1.py)


```python
seq = input()
longseq = input()

for elem in seq:
	if elem in longseq:
		allfound = True
	else:
		allfound = False


print(allfound)
```

[file](../codice/12.selftest.2.py)

::: 

::: exefatti
A program receives in input two strings, `seq` and `check`. The first  string contains small alphabetical letters and digits, the second string a mix of `'C'`, `'V'` and `'D'`. The program verifies whether the corresponding elements of the two strings match by verifying that when a small consonant appears in string `seq`, 'C' appears in string check, when a vowel appears in string `seq`, `'V'` appears in string `check`, and when a digit appears in string `seq`, `'D'` appears in string `check`. If everything matches the program outputs True, False otherwise. Example:

```bash
seq: 	"test4program" 
check:	"CVCCDCCVCCVC"
output: True

seq: 	"todaydate20251020" 
check:	"CVCVCCVCDDDDDDDDV"
output: False
```

```python
ISCON = 'C'
ISVOW = 'V'
ISDIG = 'D'
VOWELS = "aeiou"

seq = input()
check = input()

size = len(seq)
isok = True
i = 0
while i < size and isok:
	if (seq[i] in VOWELS and check[i] != ISVOW) or 
	   (seq[i] >= '0' and seq[i] <= '9' and check[i] != ISDIG) or
	   (seq[i] >= 'a' and seq[i] <= 'z' and seq[i] not in VOWELS and check[i] != ISCON):
	   isok = False
	else:
		i = i + 1

print(isok)
```

[file](../codice/13.checkstring.1.py)


```python
ISCON = 'C'
ISVOW = 'V'
ISDIG = 'D'
VOWELS = "aeiou"

seq = input()
check = input()

size = len(seq)
isok = True
for i in range(0, size):
	if (seq[i] in VOWELS and check[i] != ISVOW) or 
	   (seq[i] >= '0' and seq[i] <= '9' and check[i] != ISDIG) or
	   (seq[i] >= 'a' and seq[i] <= 'z' and seq[i] not in VOWELS and check[i] != ISCON):
	   isok = False
	   break

print(isok)
```

[file](../codice/13.checkstring.2.py)


```python
ISCON = 'C'
ISVOW = 'V'
ISDIG = 'D'
VOWELS = "aeiou"

seq = input()
check = input()

i = 0
isok = True
for elem in seq:
	if (elem in VOWELS and check[i] != ISVOW) or 
	   (elem >= '0' and elem <= '9' and check[i] != ISDIG) or
	   (elem >= 'a' and elem <= 'z' and elem not in VOWELS and check[i] != ISCON):
	   isok = False
	   break
	else:
		i = i + 1

print(isok)
```

[file](../codice/13.checkstring.3.py)


```python
ISCON = 'C'
ISVOW = 'V'
ISDIG = 'D'
VOWELS = "aeiou"

seq = input()
check = input()

i = 0
isok = True
for elem in seq:
	if elem in VOWELS:
		if check[i] != ISVOW:
			isok = False
	elif elem >= '0' and elem <= '9': # elem in DIGITS
		if check[i] != ISDIG:
			isok = False
	else:
		if check[i] != ISCON:
			isok = False
	if isok == False:
		break
	else:
		i = i + 1	
print(isok)
```

[file](../codice/13.checkstring.4.py)

::: 


::: exefatti
Write a Python program that accepts a string in input and computes and displays the string with all characters in reverse order. For example, if the user inputs string "stressed", the program computes and displays "dessert".

> Solution 1

```python
str_in = input()

str_out = "" # empty string
for elem in str_in:
	str_out = elem + str_out

print(str_out)
```

[file](../codice/90.bidirectionalstring.1.py)

> Solution 2

```python
str_in = input()

str_out = ""
size = len(str_in)

i = size - 1
while i >= 0:
	str_out = str_out + str_in[i]
	i -= 1

print(str_out)
```

[file](../codice/90.bidirectionalstring.2.py)

> Solution 3 **python-like solution**

```python
str_in = input()
str_out = str_in[::-1]
print(str_out)
```

[file](../codice/90.bidirectionalstring.3.py)

::: 

::: exefatti
In DNA strings, symbols `A` and `T` are complements of each other, as are `C` and `G`. Given a nucleotide `p`, we denote its complementary nucleotide as `pc`.
The reverse complement of a DNA string Pattern = `p1 ... pn` is the string Pattern = `pn ... p1` formed by taking the complement of each nucleotide in Pattern, then reversing the resulting string.
For example, the reverse complement of `"AGTAGGCT"` is `"AGCCTACT"`.

Write a Python program that accepts a DNA string in input and computes and displays its reverse complement.

> Solution 1

```python
seq_in = input()

#for each element in seqin,
#get the complement and
#concatenate
reco_seq = ""
for elem in seq_in:
	# position in REF
	if elem == 'A':
		comp_elem = 'T'
	elif elem == 'T':
		comp_elem = 'A'
	elif elem == 'C':
		comp_elem = 'G'
	#elif elem == 'C':
	else:
		comp_elem = 'C'

	reco_seq = comp_elem + reco_seq

print(reco_seq)
```

[file](../codice/90.reversecomplement.1.py)

> Solution 2

```python
BASES = "ACGT"
BASESCOMP = "TGCA"

seq_in = input()

#for each element in seqin,
# find the corresponding complementary neuclotide: same position of element in BASESCOMP,
#concatenate
size = len(BASES)
reco_seq = ""
for elem in seq_in:
	# position in REF
	i = 0
	found = False
	while i < size and not found:
		if BASES[i] == elem:
			found = True
		else:
			i += 1
	comp_elem = BASESCOMP[i]
	# only complement
	# compseq = compseq + comp_elem
	reco_seq = comp_elem + reco_seq

print(reco_seq)
```

[file](../codice/90.reversecomplement.2.py)

::: 


::: exefatti

Write a Python program that accepts 50 integer values and displays only those that are greater than their average.

> Solution 1

```Python
NVAL = 50

values = []		# empty list to store values
val = 0 		# accumulator for the total of the input values
for i in range(0, NVAL):
	val = int(input())
	values.append(val)
	tot += val

avg = tot / NVAL

# for each value in the list of values
for val in values:
	# if it is larger than the avg
	if val > avg:
		# display it
		print(val)
```

[file](../codice/90.largerthanaverage.1.py)

> Solution 2: **better to avoid**

```Python
NVAL = 50

values = []		# empty list to store values
for i in range(0, NVAL):
	val = int(input())
	values.append(val)

avg = sum(values) / NVAL	# it loops through all values 

# for each value in the list of values
for val in values:
	# if it is larger than the avg
	if val > avg:
		# display it
		print(val)
```

[file](../codice/90.largerthanaverage.2.py)

:::


::: exefatti
Write a Python program that accepts in input a string representing a DNA strand and computes and displays the respective number of times each nucleotide appears. The program outputs 4 integers, representing the number of occurrences of `A`, `C`, `G`, and `T`. Example:

```bash
input: "ATGCTTCAGAAAGGTCTTACG"
output: 6 4 5 6
```

> Solution 1: independent counters

```python
ELEMS = "ACGT"

dnaseq = input()

na = 0
nc = 0
ng = nt = 0

for e in dnaseq:
		if e == "A":
			na += 1
		elif e == "C":
			nc += 1
		elif e == "G":
			ng += 1
		else: #T
			nt += 1

print(na, nc, ng, nt)
```

[file](../codice/90.countACGT.1.py)

> Solution 2: counters list

```python
ELEMS = "ACGT"

dnaseq = input()

counters = [0, 0, 0, 0]
#counters = [0]*len(ELEMS)

for e in dnaseq:
    pos = ELEMS.find(e)
    counters[pos] += 1

for val in counters:
    print(val, end=" ")
print(" ")
```

[file](../codice/90.countACGT.2.py)

> Solution 3: **better to avoid**

```python
dnaseq = input()

na = dnaseq.count("A")
nc = dnaseq.count("C")
ng = dnaseq.count("G")
nt = dnaseq.count("T")

print(na, nc, ng, nt)
```

[file](../codice/90.countACGT.3.py)

:::


## Proposed exercises

::: exepro

Given two strings of equal length, we compare the characters in corresponding position. The number of mismatches between strings `p` and `q` is called the Hamming distance. Write a program that computes the Hamming distance between two DNA strings.

```python
seq1 = input()
seq2 = input()

sizee = len(seq1)
nmismatch = 0
for i in range(0, dim):
	if seq1[i] != seq2[i]:
		nmismatch += 1

print(nmismatch)
```

[file](../codice/90.DNAHammingDistance.py)

:::


::: exepro

Write a program that computes the frequency of each amino acid in a protein.

```python
ESEQ = "ACDEFGHKILMNPQRSTVYW"

pro = input()
size = len(pro)
# for each element in the ESEQ
for e in ESEQ:
	# count how many times the element appear in pro
	num = 0
	for j in range(0, size):
		if pro[j] == e:
			num += 1

	# compute the ratio w.r.t. full length
	freq = num / size
	strOut = e + “: “ + “ {0:.2f} %”.format(freq*100) + “ (“ + str(num) + “)”

# print out the feq
print(strOut)
```

[file](../codice/90.AAstats.1.py)


```python
ESEQ = "ACDEFGHKILMNPQRSTVYW"
namin = len(ESEQ)
counters = [0] * namin

pro = input()
size = len(pro)
# for each element in the ESEQ
for elem in pro:
	# find the position of the protein in ESEQ
	pos = ESEQ.find(elem)
	if pos >= 0: # we expect to find the elem
		# increment its corresponding counter
		counters[pos] += 1
	
# print out results
size = len(pro)
for i in range(0, namin):
	elem = ESEQ[i]
	# compute the ratio w.r.t. full length
	f = counters[i] / size	
	# print out the feq
	strOut = elem + “: “ + “ {0:.2f} %”.format(f*100) + “ (“ + str(counters[i]) + “)”
	print(strOut)
```

[file](../codice/90.AAstats.2.py)

:::


::: exepro
Write a Python program that repeatedly asks the user to enter integers one at a time.
The input ends when the user enters `0` (which is not part of the data set).
The program counts:

+ the number of even numbers entered,
+ the number of odd numbers entered, and
+ the total count of numbers entered

```python
STOP = 0

count_e = 0
count_o = 0

n = int(input())
while n != STOP:
	if n % 2 == 0:
		count_e += 1
	else:
		count_o += 1
	n = int(input())

count = count_e + count_o
print(count_e, count_o, count)
```

[file](../codice/90.countevenodd.py)

:::


::: exepro

Write a Python program that, given to integers received from the user in increasing order, finds and displays all the numbers **between** the two (boundary excluded) that only contain even digits.

```python
BASE = 10

start = int(input())
end = int(input())

if (start+1 % 2) == 1:	/* if it is odd, it does not have all even digits */
	start += 1

i = start
while i < end:
	num = i
	all_even = True
	while (num > 0) and all_even:
		digit = num % BASE
		if digit % 2 != 0:
			all_even = False
		num //= BASE
	if all_even:
		print(i)
	i += 2
```

[file](../codice/90.fromtoeven.1.py)


> Version with `for` statement

```python
BASE = 10

start = int(input())
end = int(input())

if (start+1 % 2) == 1:	/* if it is odd, it does not have all even digits */
	start += 1

for i in range(start, end, 2):
	num = i
	all_even = True
	while (num > 0) and all_even:
		digit = num % BASE
		if digit % 2 != 0:
			all_even = False
		num //= BASE
	if all_even:
		print(i)
```

[file](../codice/90.fromtoeven.2.py)

:::

