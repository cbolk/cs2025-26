---
exe-start: 26
exepro-start: 20
---

# Python: sequences - data structures

+ strings
+ lists

### Details

+ strings
	- unmutable
	- index
	- slices
	- empty string `""`

+ lists
	- mutable
	- index
	- slices
	- empty list `[]`


## Exercises in class

::: exefatti
Write a Python program that takes a string as input and two characters `oldc` and `newc` and **creates** a new string. The new string should contain the same content as the original input, except that every occurrence of character `oldc` is replaced by `newc`. The program displays the newly created string. Example:

```bash
"this is a test to check if my program works properly" "e" "x"
"this is a txst to chxck if my program works propxrly"
```

```python
seq = input()
oldc = input()
newc = input()

newseq = ""
for c in seq:
	if c == oldc:
		newseq = newseq + newc
	else:
		newseq = newseq + c

print(newseq)
```

[file](../codice/90.findreplacestring.py)

::: 


::: exefatti
Write a Python program that accepts a string in input and computes and displays the string with all characters in reverse order. For example, if the user inputs string "stressed", the program computes and displays "dessert".

> Solution 1

```python
str_in = input()

str_out = "" # empty string
for elem in str_in:
	str_out = elem + str_out

print(str_out)
```

[file](../codice/90.bidirectionalstring.1.py)

> Solution 2

```python
str_in = input()

str_out = ""
size = len(str_in)

i = size - 1
while i >= 0:
	str_out = str_out + str_in[i]
	i -= 1

print(str_out)
```

[file](../codice/90.bidirectionalstring.2.py)

> Solution 3 **python-like solution**

```python
str_in = input()
str_out = str_in[::-1]
print(str_out)
```

[file](../codice/90.bidirectionalstring.3.py)

::: 

::: exefatti
In DNA strings, symbols `A` and `T` are complements of each other, as are `C` and `G`. Given a nucleotide `p`, we denote its complementary nucleotide as `pc`.
The reverse complement of a DNA string Pattern = `p1 ... pn` is the string Pattern = `pn ... p1` formed by taking the complement of each nucleotide in Pattern, then reversing the resulting string.
For example, the reverse complement of `"AGTAGGCT"` is `"AGCCTACT"`.

Write a Python program that accepts a DNA string in input and computes and displays its reverse complement.

> Solution 1

```python
seq_in = input()

#for each element in seqin,
#get the complement and
#concatenate
reco_seq = ""
for elem in seq_in:
	# position in REF
	if elem == 'A':
		comp_elem = 'T'
	elif elem == 'T':
		comp_elem = 'A'
	elif elem == 'C':
		comp_elem = 'G'
	#elif elem == 'C':
	else:
		comp_elem = 'C'

	reco_seq = comp_elem + reco_seq

print(reco_seq)
```

[file](../codice/90.reversecomplement.1.py)

> Solution 2

```python
BASES = "ACGT"
BASESCOMP = "TGCA"

seq_in = input()

#for each element in seqin,
# find the corresponding complementary neuclotide: same position of element in BASESCOMP,
#concatenate
size = len(BASES)
reco_seq = ""
for elem in seq_in:
	# position in REF
	i = 0
	found = False
	while i < size and not found:
		if BASES[i] == elem:
			found = True
		else:
			i += 1
	comp_elem = BASESCOMP[i]
	# only complement
	# compseq = compseq + comp_elem
	reco_seq = comp_elem + reco_seq

print(reco_seq)
```

[file](../codice/90.reversecomplement.2.py)

::: 


::: exefatti
Write a Python program that accepts 50 integer values and displays only those that are greater than their average.

> Solution 1

```Python
NVAL = 50

values = []		# empty list to store values
val = 0 		# accumulator for the total of the input values
for i in range(0, NVAL):
	val = int(input())
	values.append(val)
	tot += val

avg = tot / NVAL

# for each value in the list of values
for val in values:
	# if it is larger than the avg
	if val > avg:
		# display it
		print(val)
```

[file](../codice/90.largerthanaverage.1.py)

> Solution 2: **better to avoid**

```Python
NVAL = 50

values = []		# empty list to store values
for i in range(0, NVAL):
	val = int(input())
	values.append(val)

avg = sum(values) / NVAL	# it loops through all values 

# for each value in the list of values
for val in values:
	# if it is larger than the avg
	if val > avg:
		# display it
		print(val)
```

[file](../codice/90.largerthanaverage.2.py)

:::


::: exefatti
Write a Python program that accepts in input a string representing a DNA strand and computes and displays the respective number of times each nucleotide appears. The program outputs 4 integers, representing the number of occurrences of `A`, `C`, `G`, and `T`. Example:

```bash
input: "ATGCTTCAGAAAGGTCTTACG"
output: 6 4 5 6
```

> Solution 1: independent counters

```python
ELEMS = "ACGT"

dnaseq = input()

na = 0
nc = 0
ng = nt = 0

for e in dnaseq:
		if e == "A":
			na += 1
		elif e == "C":
			nc += 1
		elif e == "G":
			ng += 1
		else: #T
			nt += 1

print(na, nc, ng, nt)
```

[file](../codice/90.countACGT.1.py)

> Solution 2: counters list

```python
ELEMS = "ACGT"

dnaseq = input()

counters = [0, 0, 0, 0]
#counters = [0]*len(ELEMS)

for e in dnaseq:
    pos = ELEMS.find(e)
    counters[pos] += 1

for val in counters:
    print(val, end=" ")
print(" ")
```

[file](../codice/90.countACGT.2.py)

> Solution 3: **better to avoid**

```python
dnaseq = input()

na = dnaseq.count("A")
nc = dnaseq.count("C")
ng = dnaseq.count("G")
nt = dnaseq.count("T")

print(na, nc, ng, nt)
```

[file](../codice/90.countACGT.3.py)

:::


## Proposed exercises

::: exepro
Write a Python program that repeatedly asks the user to enter integers one at a time.
The input ends when the user enters `0` (which is not part of the data set).
The program counts:

+ the number of even numbers entered,
+ the number of odd numbers entered, and
+ the total count of numbers entered

```python
STOP = 0

count_e = 0
count_o = 0

n = int(input())
while n != STOP:
	if n % 2 == 0:
		count_e += 1
	else:
		count_o += 1
	n = int(input())

count = count_e + count_o
print(count_e, count_o, count)
```

[file](../codice/90.countevenodd.py)

:::


::: exepro
Write a Python program that, given to integers received from the user in increasing order, finds and displays all the numbers **between** the two (boundary excluded) that only contain even digits.

```python
BASE = 10

start = int(input())
end = int(input())

if (start+1 % 2) == 1:	/* if it is odd, it does not have all even digits */
	start += 1

i = start
while i < end:
	num = i
	all_even = True
	while (num > 0) and all_even:
		digit = num % BASE
		if digit % 2 != 0:
			all_even = False
		num //= BASE
	if all_even:
		print(i)
	i += 2
```

[file](../codice/90.fromtoeven.1.py)


> Version with `for` statement

```python
BASE = 10

start = int(input())
end = int(input())

if (start+1 % 2) == 1:	/* if it is odd, it does not have all even digits */
	start += 1

for i in range(start, end, 2):
	num = i
	all_even = True
	while (num > 0) and all_even:
		digit = num % BASE
		if digit % 2 != 0:
			all_even = False
		num //= BASE
	if all_even:
		print(i)
```

[file](../codice/90.fromtoeven.2.py)

:::

::: exepro


```python

```

[file](../codice/90.minmaxavgseq.py)

:::
