---
exe-start: 16
exepro-start: 23
---

# Python: sequences - data structures

+ lists
+ dictionaries
+ sets

### Details

+ lists
	- mutable
	- index
	- slices
	- empty list `[]`

+ dictionaries
	- **mutable** _mapping_ of elements: key - value(s)
	- accessed by **key** (not position)
	- unordered table mapping keys (unmutable) to values (mutable)
	- empty dictionary: `{}`


+ operations for sequences (strings, lists)

| Operation | Description |
|-----------|-------------|
| `x in seq` | Returns `True` if `x` is in the sequence, `False` otherwise |
| `x not in seq` | Returns `True` if `x` is not in the sequence, `False` otherwise |
| `seq1 + seq2` | Concatenation of two sequences |
| `seq * num`, `num * seq` | Repetition of sequence `num` times |
| `seq[i]` | Access element at index `i` |
| `seq[i:j]` | Slice from index `i` to `j` (exclusive) |
| `len(seq)` | Returns the length of the sequence |
| `min(seq)` | Returns the minimum element in the sequence |
| `max(seq)` | Returns the maximum element in the sequence |
| `iter(seq)` | Returns an iterator for the sequence |
| `for x in seq:` | Iterates over each element in the sequence |
| `[expr for x in seq]` | List comprehension - iterates and creates a new list |


+ operations on lists as mutable objects:

| Operation | Description |
|-----------|-------------|
| `seq[i] = el` | Index assignment: change item at index `i` |
| `seq[i:j] = el` | Slice assignment: replace elements from index `i` to `j` (exclusive) |
| `seq[i:j:k] = el` | Slice assignment with stride `k` |
| `del seq[i]` | Delete element at index `i` |
| `del seq[i:j]` | Delete slice from index `i` to `j` (exclusive) |
| `del seq[i:j:k]` | Delete slice from index `i` to `j` with stride `k` |


+ operations on dictionaries

| Operation | Description |
|-----------|-------------|
| `d[k]` | Retrieves element by key `k` |
| `d[k] = x` | Creates or updates element for key `k` |
| `del d[k]` | Removes element by key `k` |
| `len(d)` | Returns the number of keys |
| `k in d` | Returns `True` if key `k` is in dictionary, `False` otherwise |
| `k not in d` | Returns `True` if key `k` is not in dictionary, `False` otherwise |
| `iter(d)` | Returns an iterator over the keys |
| `for k in d:` | Iterates over each key in the dictionary |

+ operations on sets



## Exercises in class

::: exefatti

**Q1**: What does this program do?

**Q2**: Is there any difference in the problems they solve?

```bash
in: narrative alternatives
out: True

in: stare alternatives
out: True

in: store alternatives
out: True
```

```python
seq = input()
longseq = input()

allfound = True
for elem in seq:
	if elem not in longseq:
		allfound = False
		break

print(allfound)
```

[file](../codice/12.selftest.1.py)


```python
seq = input()
longseq = input()

for elem in seq:
	if elem in longseq:
		allfound = True
	else:
		allfound = False


print(allfound)
```

[file](../codice/12.selftest.2.py)

::: 

::: exefatti

Write a Python program that accepts in input a string representing a DNA strand and computes and displays the respective number of times each nucleotide appears. The program outputs 4 integers, representing the number of occurrences of `A`, `C`, `G`, and `T`. Example:

```bash
input: "ATGCTTCAGAAAGGTCTTACG"
output: 6 4 5 6
```

Solution 1: independent counters

```python
ELEMS = "ACGT"

dnaseq = input()

na = 0
nc = 0
ng = nt = 0

for e in dnaseq:
		if e == "A":
			na += 1
		elif e == "C":
			nc += 1
		elif e == "G":
			ng += 1
		else: #T
			nt += 1

print(na, nc, ng, nt)
```

[file](../codice/17.countACGT.1.py)

Solution 2: counters list

```python
ELEMS = "ACGT"

dnaseq = input()

counters = [0, 0, 0, 0]
#counters = [0]*len(ELEMS)

for e in dnaseq:
    pos = ELEMS.find(e)
    counters[pos] += 1

for val in counters:
    print(val, end=" ")
print(" ")
```

[file](../codice/17.countACGT.2.py)

Solution 3: **better to avoid**

```python
dnaseq = input()

na = dnaseq.count("A")
nc = dnaseq.count("C")
ng = dnaseq.count("G")
nt = dnaseq.count("T")

print(na, nc, ng, nt)
```

[file](../codice/17.countACGT.3.py)


Solution 3: with dictionary -- added at the end

```python
ELEMS = "ACGT"

dnaseq = input()

# dictionary initialisation
count = {}
for e in ELEMS:
	count[e] = 0


for e in dnaseq:
	count[e] = count[e]+1

## uniform visualisation with previous methods
for k, v in count.items():
	print(v, end=" ")
print(" ")
```

[file](../codice/17.countACGT.4.py)


:::


::: exefatti

A `k`-mer is a string of length `k`. Write a Python program that accepts in input 1) a DNA string and b) an integer size `k` and computes the _sorted_  (in alphabetical order) list of all `k`-mer of that string.

```python
dnaseq = input()
k = int(input())

# extract all possible k-mers
tdim = len(dnaseq)
lastpos = tdim-k+1
kmers = []
for i in range(0, lastpos):
    # take a subsequence of length k of adjacent elements
    elem = dnaseq[i:i+k]
    # if it is not already part of the list, insert it
    if elem not in kmers:
        kmers.append(elem)

kmers.sort()

for km in kmers:
    print(km, end=" ")
print()
```

[file](../codice/18.kmerlist.list.py)

```python
dnaseq = input()
k = int(input())

# extract all possible k-mers
tdim = len(dnaseq)
lastpos = tdim-k+1
kmers = set()
for i in range(0, lastpos):
    # take a subsequence of length k of adjacent elements
    elem = dnaseq[i:i+k]
    # if it is not already part of the list, insert it
    kmers.add(elem)

kmers_sorted = sorted(kmers)

for km in kmers_sorted:
    print(km, end=" ")
print("")
```

[file](../codice/18.kmerlist.set.py)

:::

::: exefatti

Write a Python program that receives a sequence of words, one of per line, until the user inserts an empty line. The program computes and displays the word that appears more often. There is a single word that matches this requirement.

```bash
apple
orange
banana
apple
orange
apple
apple
orange
banana
apple
orange
apple

apple 6
```


```python
STOP = ""

frequencies = {}

word = input()
if word != STOP:
	maxfword = word
	maxfreq = 1
	frequencies[word] = 1
	word = input()
	while word != STOP:
		#increment frequencies
		if word in frequencies.keys():
			num = frequencies[word] + 1
		else:
			num = 1
		frequencies[word] = num
		if num > maxfreq:
			maxfword = word
			maxfreq = num
		#next word
		word = input()
else:
	maxfword = ""
	maxfreq = 0
print(maxfword, maxfreq)
```

[file](../codice/19.mostfrequentword.dic.py)


```python
STOP = ""

frequencies = []

word = input()
if word != STOP:
	maxfword = word
	maxfreq = 1
	frequencies.append([word, 1])
	word = input()
	while word != STOP:
		found = False
		for pair in frequencies:
			if pair[0] == word:
				found = True
				pair[1] = pair[1]+1
				break
		if found:
			num = pair[1]
		else:
			num = 1
			frequencies.append([word, num])

		if num > maxfreq:
			maxfword = word
			maxfreq = num
		#next word
		word = input()
else:
	maxfword = ""
	maxfreq = 0
print(maxfword, maxfreq)
```

[file](../codice/19.mostfrequentword.list.py)

:::

::: exefatti

Write a Python program that reads a sentence (a string) from the user and identifies the initial letter that appears most frequently as the first character of the words in the sentence (no distinction between capital and small letters). The program builds and displays a list of all the words from the sentence that start with that most frequent initial character.
Words should be considered as sequences of characters separated by spaces.
If multiple letters are tied for highest frequency, you may choose any one of them


```python
CHARNUM = 26 # a - z

user_sentence = input()

#counters
frequencies = [0]*CHARNUM
wordsbyinitial = [[] for _ in range(CHARNUM)]

words = user_sentence.split()

if words: # Only proceed if there are words in the sentence
    #first word
    firstword = words[0]
    most_frequent_letter = firstword[0].lower()
    most_frequent_count = 1
    pos = ord(most_frequent_letter)-ord('a')
    frequencies[pos] = 1
    wordsbyinitial[pos].append(firstword)
    # remaining words
    for word in words[1:]:
        if word:  # Ensure the word is not an empty string
            initial_letter = word[0].lower()  # Get the first letter and convert to lowercase
            pos = ord(initial_letter)-ord('a')
            #add it to the correct group of words with the same initial 
            wordsbyinitial[pos].append(word)
            #keeping track of frequencies
            frequencies[pos] += 1 
            freqnum = frequencies[pos] 
            if freqnum > most_frequent_count:
                most_frequent_letter = initial_letter
                most_frequent_count = freqnum

    result_words = wordsbyinitial[ord(most_frequent_letter)-ord('a')]
    print(result_words)
else:
    print("\nNo words found in the sentence.")
```

[file](../codice/20.mostfrequentinitials.py)


Comment on AI-generated solution

```python
# Get input from the user
user_sentence = input()

words = user_sentence.split()

initial_letter_counts = {}

if words: # Only proceed if there are words in the sentence
    for word in words:
        if word:  # Ensure the word is not an empty string
            initial_letter = word[0].lower()  # Get the first letter and convert to lowercase
            initial_letter_counts[initial_letter] = initial_letter_counts.get(initial_letter, 0) + 1

    most_frequent_letter = ''
    max_count = 0

    # Find the most frequent initial letter
    for letter, count in initial_letter_counts.items():
        if count > max_count:
            max_count = count
            most_frequent_letter = letter

    # Build the list of words starting with the most frequent initial letter
    result_words = []
    for word in words:
        if word and word[0].lower() == most_frequent_letter:
            result_words.append(word)

    print(result_words)
else:
    print("\nNo words found in the sentence.")
```

:::


::: exefatti

Write a Python program that accepts a sequence of integer values that is considered finished when the user inserts value 0. The program reports the list of unique values, sorted in a decreasing order.

```python
STOP = 0

numbers = []

value = int(input())
while value != STOP:
	if value not in numbers:
		numbers.append(value)
	value = int(input())

sorted_numbers = sorted(numbers, reverse=True)
print(sorted_numbers)
```

[file](../codice/20.uniquevalues.list.py)

```python
STOP = 0

numbers = set()

value = int(input())
while value != STOP:
	numbers.add(value)
	value = int(input())

sorted_numbers = sorted(numbers, reverse=True)
print(sorted_numbers)
```

[file](../codice/20.uniquevalues.set.py)


Comment on this co-pilot solution.

```python
numbers = set()

while True:
    value = int(input())
    if value == 0:
        break
    numbers.add(value)  

# convert to list and sort in decreasing order
sorted_numbers = sorted(numbers, reverse=True)

print(sorted_numbers)
```

:::


## Proposed exercises

::: exepro

Find an alternative solution to the following problem:

Write a program that accepts in input a string corresponding to a protein and it computes and displays the frequency of each amino acid in it. 


```python
ESEQ = "ACDEFGHKILMNPQRSTVYW"
namin = len(ESEQ)
counters = [0] * namin

pro = input()
size = len(pro)
# for each element in the ESEQ
for elem in pro:
	# find the position of the protein in ESEQ
	pos = ESEQ.find(elem)
	if pos >= 0: # we expect to find the elem
		# increment its corresponding counter
		counters[pos] += 1
	
# print out results
size = len(pro)
for i in range(0, namin):
	elem = ESEQ[i]
	# compute the ratio w.r.t. full length
	f = counters[i] / size	
	# print out the feq
	strOut = elem + “: “ + “ {0:.2f} %”.format(f*100) + “ (“ + str(counters[i]) + “)”
	print(strOut)
```

[file](../codice/90.AAstats.2.py)

:::

::: exepro

A `k`-mer is a string of length `k`. We define `Count(Text, Pattern)` as the number of times that a `k`-mer Pattern appears as a substring of Text. For example,
`k`-mer `ACTAT` appears 3 times in string `ACAACTATGCATACTATCGGGAACTATCCT`
Note that `k`-mer `ATA` appears 3 times (not 2) in string `CGATATATCCATAG`, because we should account for overlapping occurrences of the pattern in the string.
Write a program that receives in input a DNA string and a `k`-mer and computes and prints out the number of time the `k`-mer appears in the string. Example:

```bash

input: ACAACTATGCATACTATCGGGAACTATCCT
ACTAT
output: 3
```

```python
text = input("text: ")
kmer = input("k-mer: ")

num = 0
tsize = len(text)
ksize = len(kmer)
stop = tsize - ksize + 1
for i in range(0, stop):
    equal = 1
    j = 0
    while j < ksize and equal:
        if text[i+j] != kmer[j]:
            equal = 0
        j += 1
    num += equal

print(num)
```

[file](../codice/90.kmeroccurrences.py)

:::

## Proposed exercises

::: exepro

Write a Python program that reads a sequence of temperatures (in Celsius), entered by the user as floating-point numbers separated by commas. The program computes the median temperature and the average one, then it displays them.

Solve the problem by planning an algorithm that does not rely on existing functions, that would defeat the entire purpose of this exercise. Do the exercise manually to determine "when" you would perform the various computations.


```bash
input: 12.3, 15.8, 9.4, 11.0, 14.2, 13.6, 10.5, 16.1, 12.9, 14.7
output: 13.25 13.05

input: 12.3, 15.8, 9.4, 11.0, 14.2, 13.6, 10.5, 16.1, 12.9, 14.7, 13.05
output: 13.05 13.05
```

::: 

::: exepro
::: 
