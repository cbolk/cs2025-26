---
exe-start: 16
exepro-start: 23
---

# Python: sequences - data structures

+ lists
+ dictionaries
+ sets

### Details

+ lists
	- mutable
	- index
	- slices
	- empty list `[]`

+ dictionaries
	- **mutable** _mapping_ of elements: key - value(s)
	- accessed by **key** (not position)
	- unordered table mapping keys (unmutable) to values (mutable)
	- empty dictionary: `{}`


## Exercises in class

::: exefatti

**Q1**: What does this program do?

**Q2**: Is there any difference in the problems they solve?

```bash
in: narrative alternatives
out: True

in: stare alternatives
out: True

in: store alternatives
out: True
```

```Python
seq = input()
longseq = input()

allfound = True
for elem in seq:
	if elem not in longseq:
		allfound = False
		break

print(allfound)
```

[file](../codice/12.selftest.1.py)


```Python
seq = input()
longseq = input()

for elem in seq:
	if elem in longseq:
		allfound = True
	else:
		allfound = False


print(allfound)
```

[file](../codice/12.selftest.2.py)

::: 

::: exefatti

Write a Python program that accepts in input a string representing a DNA strand and computes and displays the respective number of times each nucleotide appears. The program outputs 4 integers, representing the number of occurrences of `A`, `C`, `G`, and `T`. Example:

```bash
input: "ATGCTTCAGAAAGGTCTTACG"
output: 6 4 5 6
```

Solution 1: independent counters

```Python
ELEMS = "ACGT"

dnaseq = input()

na = 0
nc = 0
ng = nt = 0

for e in dnaseq:
		if e == "A":
			na += 1
		elif e == "C":
			nc += 1
		elif e == "G":
			ng += 1
		else: #T
			nt += 1

print(na, nc, ng, nt)
```

[file](../codice/17.countACGT.1.py)

Solution 2: counters list

```Python
ELEMS = "ACGT"

dnaseq = input()

counters = [0, 0, 0, 0]
#counters = [0]*len(ELEMS)

for e in dnaseq:
    pos = ELEMS.find(e)
    counters[pos] += 1

for val in counters:
    print(val, end=" ")
print(" ")
```

[file](../codice/17.countACGT.2.py)

Solution 3: **better to avoid**

```Python
dnaseq = input()

na = dnaseq.count("A")
nc = dnaseq.count("C")
ng = dnaseq.count("G")
nt = dnaseq.count("T")

print(na, nc, ng, nt)
```

[file](../codice/17.countACGT.3.py)


Solution 4: with dictionary -- added at the end

```Python
ELEMS = "ACGT"

dnaseq = input()

# dictionary initialisation
count = {}
for e in ELEMS:
	count[e] = 0


for e in dnaseq:
	count[e] = count[e]+1  # count[e] += 1

## uniform visualisation with previous methods
for k, v in count.items():
	print(v, end=" ")
print(" ")
```

[file](../codice/17.countACGT.4.py)


:::


::: exefatti

A `k`-mer is a string of length `k`. Write a Python program that accepts in input 1) a DNA string and b) an integer size `k` and computes the _sorted_  (in alphabetical order) list of all `k`-mer of that string.

```bash
input: ACTGACACGATGACGAGGAGA 
output: ACAC ACGA ACTG AGGA ATGA CACG CGAG CGAT CTGA GACA GACG GAGA GAGG GATG GGAG TGAC
```

```Python
dnaseq = input()
k = int(input())

# added to remove possible spaces at the end of the input string
dnaseq = dnaseq.strip()

# extract all possible k-mers
tdim = len(dnaseq)
lastpos = tdim-k+1
kmers = []
for i in range(0, lastpos):
    # take a subsequence of length k of adjacent elements
    elem = dnaseq[i:i+k]
    # if it is not already part of the list, insert it
    if elem not in kmers:
        kmers.append(elem)

kmers.sort()

for km in kmers:
    print(km, end=" ")
print()
```

[file](../codice/18.kmerlist.list.py)

```Python
dnaseq = input()
k = int(input())

# added to remove possible spaces at the end of the input string
dnaseq = dnaseq.strip()

# extract all possible k-mers
tdim = len(dnaseq)
lastpos = tdim-k+1
kmers = set()
for i in range(0, lastpos):
    # take a subsequence of length k of adjacent elements
    elem = dnaseq[i:i+k]
    # if it is not already part of the list, insert it
    kmers.add(elem)

kmers_sorted = sorted(kmers)

for km in kmers_sorted:
    print(km, end=" ")
print("")
```

[file](../codice/18.kmerlist.set.py)

:::

## Proposed exercises

::: exepro

Find an alternative solution to the following problem:

Write a program that accepts in input a string corresponding to a protein and it computes and displays the frequency of each amino acid in it. 


```python
ESEQ = "ACDEFGHKILMNPQRSTVYW"
namin = len(ESEQ)
counters = [0] * namin

pro = input()
size = len(pro)
# for each element in the ESEQ
for elem in pro:
	# find the position of the protein in ESEQ
	pos = ESEQ.find(elem)
	if pos >= 0: # we expect to find the elem
		# increment its corresponding counter
		counters[pos] += 1
	
# print out results
size = len(pro)
for i in range(0, namin):
	elem = ESEQ[i]
	# compute the ratio w.r.t. full length
	f = counters[i] / size	
	# print out the feq
	strOut = elem + “: “ + “ {0:.2f} %”.format(f*100) + “ (“ + str(counters[i]) + “)”
	print(strOut)
```

[file](../codice/90.AAstats.2.py)

:::

::: exepro

A `k`-mer is a string of length `k`. We define `Count(Text, Pattern)` as the number of times that a `k`-mer Pattern appears as a substring of Text. For example,
`k`-mer `ACTAT` appears 3 times in string `ACAACTATGCATACTATCGGGAACTATCCT`
Note that `k`-mer `ATA` appears 3 times (not 2) in string `CGATATATCCATAG`, because we should account for overlapping occurrences of the pattern in the string.
Write a program that receives in input a DNA string and a `k`-mer and computes and prints out the number of time the `k`-mer appears in the string. Example:

```bash

input: ACAACTATGCATACTATCGGGAACTATCCT
ACTAT
output: 3
```

```python
text = input("text: ")
kmer = input("k-mer: ")

num = 0
tsize = len(text)
ksize = len(kmer)
stop = tsize - ksize + 1
for i in range(0, stop):
    equal = 1
    j = 0
    while j < ksize and equal:
        if text[i+j] != kmer[j]:
            equal = 0
        j += 1
    num += equal

print(num)
```

[file](../codice/90.kmeroccurrences.py)

:::

::: exepro

Write a Python program that reads a sequence of temperatures (in Celsius), entered by the user as floating-point numbers separated by commas. The program computes the median temperature and the average one, then it displays them.

Solve the problem by planning an algorithm that does not rely on existing functions, that would defeat the entire purpose of this exercise. Do the exercise manually to determine "when" you would perform the various computations.


```bash
input: 12.3, 15.8, 9.4, 11.0, 14.2, 13.6, 10.5, 16.1, 12.9, 14.7
output: 13.25 13.05

input: 12.3, 15.8, 9.4, 11.0, 14.2, 13.6, 10.5, 16.1, 12.9, 14.7, 13.05
output: 13.05 13.05
```

::: 


::: exepro

Write a Python program that reads a sentence (a string) from the user and identifies the initial letter that appears most frequently as the first character of the words in the sentence (no distinction between capital and small letters). The program builds and displays a list of all the words from the sentence that start with that most frequent initial character.
Words should be considered as sequences of characters separated by spaces.
If multiple letters are tied for highest frequency, you may choose any one of them


```python
CHARNUM = 26 # a - z

user_sentence = input()

#counters
frequencies = [0]*CHARNUM
wordsbyinitial = [[] for _ in range(CHARNUM)]

words = user_sentence.split()

if words: # Only proceed if there are words in the sentence
    #first word
    firstword = words[0]
    most_frequent_letter = firstword[0].lower()
    most_frequent_count = 1
    pos = ord(most_frequent_letter)-ord('a')
    frequencies[pos] = 1
    wordsbyinitial[pos].append(firstword)
    # remaining words
    for word in words[1:]:
        if word:  # Ensure the word is not an empty string
            initial_letter = word[0].lower()  # Get the first letter and convert to lowercase
            pos = ord(initial_letter)-ord('a')
            #add it to the correct group of words with the same initial 
            wordsbyinitial[pos].append(word)
            #keeping track of frequencies
            frequencies[pos] += 1 
            freqnum = frequencies[pos] 
            if freqnum > most_frequent_count:
                most_frequent_letter = initial_letter
                most_frequent_count = freqnum

    result_words = wordsbyinitial[ord(most_frequent_letter)-ord('a')]
    print(result_words)
else:
    print("\nNo words found in the sentence.")
```

[file](../codice/90.mostfrequentinitials.py)



```python
# Comment on AI-generated solution
# Get input from the user
user_sentence = input()

words = user_sentence.split()

initial_letter_counts = {}

if words: # Only proceed if there are words in the sentence
    for word in words:
        if word:  # Ensure the word is not an empty string
            initial_letter = word[0].lower()  # Get the first letter and convert to lowercase
            initial_letter_counts[initial_letter] = initial_letter_counts.get(initial_letter, 0) + 1

    most_frequent_letter = ''
    max_count = 0

    # Find the most frequent initial letter
    for letter, count in initial_letter_counts.items():
        if count > max_count:
            max_count = count
            most_frequent_letter = letter

    # Build the list of words starting with the most frequent initial letter
    result_words = []
    for word in words:
        if word and word[0].lower() == most_frequent_letter:
            result_words.append(word)

    print(result_words)
else:
    print("\nNo words found in the sentence.")
```

:::


::: exepro

Write a Python program that accepts a sequence of integer values that is considered finished when the user inserts value 0. The program reports the list of unique values, sorted in a decreasing order.

```python
STOP = 0

numbers = []

value = int(input())
while value != STOP:
	if value not in numbers:
		numbers.append(value)
	value = int(input())

sorted_numbers = sorted(numbers, reverse=True)
print(sorted_numbers)
```

[file](../codice/90.uniquevalues.list.py)

```python
STOP = 0

numbers = set()

value = int(input())
while value != STOP:
	numbers.add(value)
	value = int(input())

sorted_numbers = sorted(numbers, reverse=True)
print(sorted_numbers)
```

[file](../codice/90.uniquevalues.set.py)


```python
# Comment on this co-pilot solution.
numbers = set()

while True:
    value = int(input())
    if value == 0:
        break
    numbers.add(value)  

# convert to list and sort in decreasing order
sorted_numbers = sorted(numbers, reverse=True)

print(sorted_numbers)
```

:::
