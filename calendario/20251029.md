---
exe-start: 22
exepro-start: 34
---

# Python: functions

+ objectives: problem decomposition, abstraction and complexity handling, reuse
+ variable scope and visibility

### Details

```py
def _name_ (_arguments_):
	# code
	# 
	return _results_
```

+ _arguments_ constitute the data (prepared by another part of the solution) the function has to work on -- the function `receives in input` the information to be processed
+ except for specific functions whose aim is to **ask the user for data**, most functions receive in input and do not perform data acquisition from the user
+ one statement functions are not effective: no abstraction, context switch cost

## Exercises in class

::: exefatti

Write a Python program that accepts in input two strictly positive numbers, `n` and `k`, with `k <= n`. The program computes the number of combinations of `n` elements, taking `k` at a time.

Version with no functions

```python
# controlled acquisition n (strictly positive)
n = int(input())
while n <= 0:
	n = int(input())
# controlled acquisition k (included in interval [1, n])
k = int(input())
while k <= 0 or k > n:
	k = int(input())

# factorial n
fn = 1
for i in range(2, n+1):
	fn = fn * i
# factorial k
fk = 1
for i in range(2, k+1):
	fk = fk * i
# factorial n-k
diff = n-k
fnk = 1
for i in range(2, diff+1):
	fnk = fnk * i
# combinations
comb = fn // (fk * fnk)

print(comb)
```

[file](../codice/22.combinationsnk.nosub.py)


Version with functions

```python
# CONSTANTS 

# FUNCTIONS
''' 
function that asks the user a strictly positive integer, repeating the request till the value meets 
the requirements. 
the function returns the value to the caller
'''
def getPositive():
	val = int(input())
	while val <= 0:
		val = int(input())
	return val

''' 
funciton that asks the user an integer included in an interval, boundaries included. 
it repeats the request till the value meets the requirements
the function returns the value to the caller
'''
def getInsideInterval(lowerBound, upperBound):
	val = int(input())
	while val < lowerBound or val > upperBound:
		val = int(input())
	return val

''' 
function that receives in input a positive integer (for sure) and computes and returns its factorial
'''
def factorial(value):
	f = 1
	i = value
	while i > 1:
		f = f * i
		i -= 1
	return f

# MAIN FLOW
# THE TASK THE PROGRAM PERFORM TO SOLVE THE PROBLEM
# controlled acquisition n (strictly positive)
n = getPositive()

# controlled acquisition k (included in interval [1, n])
k = getInsideInterval(1, n)

# factorial n
fn = factorial(n)
# factorial k
fk = factorial(k)
# factorial n-k
diff = n-k
fnk = factorial(diff)
# combinations
comb = fn // (fk * fnk)

print(comb)
```

[file](../codice/22.combinationsnk.sub.py)

:::


::: exefatti
Write a Python function that receives in input a list of integer values and computes and returns the minimum, the maximum and the average of all values.

```python
def minmaxavg(numberList):
	# initialise min max and total to the first element
	minval = numberList[0]
	maxval = numberList[0]
	tot = numberList[0]

	# for all elements in the list starting from the second one
	for elem in numberList[1:]:
		# check if I need to update either the max or the min
		if elem >= maxval:
			maxval = elem
		elif elem <= minval:
			minval = elem
		# add the element to the total
		tot += elem

	avg = tot / len(numberList)

	return minval, maxval, avg
```

[file](../codice/23.minmaxavg.sub.1.py)


Alternative version where the loop re-examines the first element, therefore a new initilisation is needed

```python
def minmaxavg(numberList):
	# initialise min max and total to the first element
	minval = numberList[0]
	maxval = numberList[0]
	tot = 0	# I will consider the first element again .. 

	# for all elements in the list 
	# the first comparison for min and max is redundant, but is not incorrect
	for elem in numberList:
		# check if I need to update either the max or the min
		if elem >= maxval:
			maxval = elem
		elif elem <= minval:
			minval = elem
		# add the element to the total
		tot += elem

	avg = tot / len(numberList)

	return minval, maxval, avg
```

[file](../codice/23.minmaxavg.sub.2.py)


**Solution to be avoided**

```python
def minmaxavg(numberList):
	# initialise min max and total to the first element
	minval = min(numberList)
	maxval = max(numberList)
	avg = sum(numberList) / len(numberList)

	return minval, maxval, avg
```

:::


::: exefatti
Write a Python function that receives in input a string `seq` and a substring `subs` and counts and returns the number of times subs appears in seq, including occurrences partially overlapped. Example:

```bash
input:
AABBCABAAAA
AA
output:
4
``` 

```python
def countOccurrences(seq, subs):
	# from the beginning to the long sequence seq
	# to the last point where subs can start
	# AAACTCCTGCGACC ACAC
	#           ^
	# 
	dim_long = len(seq)
	dim_short = len(subs)
	lastpos = dim_long - dim_short + 1

	num = 0
	# for every slice in the long sequence of the 
	# same size of the subs
	for i in range(0, lastpos):
		# if the slice is equal to subs
		if seq[i:i+dim_short] == subs:
			# increment the counter
			num += 1
	return num


### FOR TESTING PURPOSES
longstring = "AATATATCGCGATATATTATATAAAA"
shortstring = "AT"

res = countOccurrences(longstring, shortstring)
print(res)

```

[file](../codice/24.countsubsequences.sub.py)

**Solution that does not work (and would not be a meaningful exercise to propose)**


```python
def countoverlapped(seq, subs):
	return seq.count(subs)
```

:::


::: exefatti
Write a Python function that receives in input a DNA string and an integer `k` and computes and returns a list of all `k`-mers.

```python
def getkmers(seq):
    tdim = len(seq)
    #the last position where a kmer can start
    lastpos = tdim - k + 1
    #the list of kmers
    kmers = []
    for i in range(0, lastpos):
        # take a subsequence of length k of adjacent elements
        elem = seq[i:i+k]
        # if it is not already part of the list, insert it
        if elem not in kmers:
            kmers.append(elem)

    return kmers
```

[file](../codice/25.getkmers.sub.py)


Solution based on *sets*: the `.add()` method takes care of not having replicas of the same element (it still requires the same kind of action we are performing with the list and our explicit control), then we incur in the creation of the list (by iterating over all the elements in the set and creating a corresponding element in the list)

```python
def getkmers(seq):
    tdim = len(seq)
    #the last position where a kmer can start
    lastpos = tdim - k + 1
    #the list of kmers
    kmers_set = set()
    for i in range(0, lastpos):
        # take a subsequence of length k of adjacent elements
        elem = seq[i:i+k]
        kmers_set.add(elem)

    mkers = list(kmers_set)
    return kmers
```

:::

## Proposed exercises

::: exepro

Write a Python program that receives in input a sequence of integer values, one at a time, that is concluded when the user inserts value 0. The program computes and displays the smallest, biggest and average of the input values.

```python
STOPVAL = 0

def minmaxavg(l):
	minval = maxval = tot = l[0]
	for elem in l[1:]:
		tot += elem
		if elem <= minval:
			minval = elem
		elif elem > maxval:
			maxval = elem

	avgval = tot / len(l)

	return minval, maxval, avgval

#main flow
values = []

num = int(input())
while val != STOPVAL:
	values.append(val)
	num = int(input())

small, big, avg = minmaxavg(values)
print(small, big, avg)
```

[file](../codice/90.minmaxavg.main.py)

:::

::: exepro
Write a function that receives in input list of integers `values` and a value `k` and returns the list of all **distinct** pairs of elements in `values` such that their sum is `k`.

```python
def pairssumk(values, k):
	size = len(values)
	sumk = []
	posi = 0
	while posi < size:
		posj = posi + 1
		while posj < size:
			if values[posi] + values[posj] == k:
				pair = sorted([values[posi], values[posj]])
				if pair not in sumk:
					sumk.append(pair)
			posj += 1
		posi += 1
	return sumk

```

[file](../codice/90.pairssumk.sub.py)

:::


> Develop Python functions to implent the common functionalities developed up to now.


::: exepro
Write a Python function that receives in input an integer and returns `True` if the input value corresponds to a _leap_ year, `False` otherwise. 

:::


::: exepro
Write a Python function that receives in input an integer and returns `True` if the input value is a prime number, `False` otherwise. 

:::

::: exepro
Write a Python function that receives in input a string and returns `True` if it is a palindromic string, `False` otherwise. 

:::


::: exepro
Write a Python program that receives in input a collection of words, one for each line, until an empty line is entered. The program computes and visualises for each word the lists of anagrams of the word itself.

```bash
listen
cat
silent
act
stressed
enlist
banana
tac
ananas
desserts

output:
listen silent enlist 
cat act tac 
stressed desserts 
banana 
ananas 
```


```python
def isanagram(word1, word2):
	size1 = len(word1)
	size2 = len(word2)

	if size1 == size2:
		used = [0]*size1
	else:
		res = False
	return res

word_anagrams = {}
latest_word = input().strip()
while entry != "":
	# search if there is already an anagram of the new word in the collection
	for element in word_anagrams:
		if isanagram(latest_word, element):
			anagrams = word_anagrams[element]
			word_anagrams[element] = anagrams.append()
		else:
			# at present there is no anagram of the present word
			words[latest_word] = []

	# next entry
	entry = input().strip()

for word, anagrams in word_anagrams.items():
	print(word, end=" ")
	for a in anagrams:
		print(a, end= " ")
	print()

```

[file](../codice/90.groupsofanagrams.py)

:::

::: exepro
Write a function that takes two strings as input, `seq1` and `seq2`. The function computes and returns the list of _substrings_ that belong to one input string but not to the other and vice versa. Recall that a _substring_ is what you obtain from a string when you remove 0 or more characters from the beginning or the end of the string. Example:

```bash
input: aabbccdd acccdzza
output: [’aabb’, ’aabbc’, ’aabbcc’, ’aabbccd’, ’aabbccdd’, ’aabc’, ’aabcd’, ’abb’, ’abbc’, ’abbcc’, ’abbccd’, 
’abbccdd’, ’abc’, ’abcd’, ’bb’, ’bbc’, ’bbcc’, ’bbccd’, ’bbccdd’, ’bcc’, ’bccd’, ’bccdd’, ’bcd’, ’cc’, 
’ccd’, ’ccdd’, ’cdd’, ’dd’]
```

:::