---
exe-start: 48
exepro-start: 57
---

## Exercises in class

::: exefatti

Write a function `find_pairs_sum()` that takes a list of integers and a `target` value. The function returns all unique pairs of numbers from the list that sum to the target value. Each pair should be sorted *in an increasing order* and pairs should not be duplicated.

Example:
```bash
numbers = [2, 7, 11, 15, 3, 6, 8]
target = 10
output: [[2, 8], [3, 7]]
```


```python
def find_pairs_sum(numbers, target):
    size = len(numbers)
    pairs = []
    
    # Iterate through all possible pairs
    for i in range(size):
        for j in range(i + 1, size):
            # Check if pair sums to target
            if numbers[i] + numbers[j] == target:
                # Sort the pair to maintain consistency and avoid duplicates
                # pair = sorted([numbers[i], numbers[j]])
                if numbers[i] <= numbers[j]:
                    pair = list(numbers[i], numbers[j])
                else:
                    pair = list(numbers[j], numbers[i])
                # Add only if not already in list
                if pair not in pairs:
                    pairs.append(pair)
    
    return pairs


# Test --------

numbers = [2, 7, 11, 15, 3, 6, 8]
target = 10
result = find_pairs_sum(numbers, target)
print(result)  # [[2, 8], [3, 7]]

# Focus: Lists, nested loops, duplicate handling

```

[file](../codice/47.sumtotarget.py)


:::


::: exefatti

You have a text file `measurements.txt` with temperature readings:
```txt
location,temperature,date
Rome,22.5,2025-01-15
Cannes,19.3,2025-01-15
Madrid,23.1,2025-01-16
Rome,20.8,2025-01-15
New York,22.8,2025-01-17
Cannes,18.9,2025-01-16
```

Write functions to:
1. `load_measurements(filename)` - Load data into a dictionary structure
2. `calculate_average_per_location(data)` - Calculate average temperature per location
3. `find_extreme_readings(data)` - Find highest and lowest temperature with location
4. `save_summary(averges, extremes, output_filename)` - Save results to a human-readable text file in the format:

```txt
Temperature Measurement Summary
-----------------------------------
>> Extreme Readings:
Highest: 54.40°C at Basra on 2025-07-01
Lowest: -35.33°C at Yakutsk on 2024-01-12
>> Average Temperatures by Location:
Rome: 23.53°C
Cannes: 22.60°C
...

```


```python
def load_measurements(filename):
    """Load txt data into dictionary: {location: [(temp, date), ...]}"""
    data = {}
    
    try:
        with open(filename, 'r') as file:
            # Skip header line
            header = file.readline()
            
            # Process data lines
            for line in file:
                line = line.strip()
                if line:
                    parts = line.split(',')
                    location = parts[0]
                    temperature = float(parts[1])
                    date = parts[2]
                    
                    # Populate dict
                    if location not in data:
                        data[location] = []
                    data[location].append((temperature, date))
    
    except FileNotFoundError:
        print(f"Error: File '{filename}' not found")
        return {}
    
    return data

def calculate_average_per_location(data):
    """Calculate average temperature for each location"""
    averages = {}

    # compute for each key
    for location, readings in data.items():
        total = 0.0
        count = 0
        for temp, _ in readings:
            total += temp
            count += 1

        if count > 0:
            averages[location] = total / count 
        else:
            averages[location] = 0
    
    return averages

def find_extreme_readings(data):
    """Find highest and lowest temperatures across all locations"""
    # Initialisation to first value

    min_location = max_location = next(iter(data))
    readings = data[max_location]
    min_temp = max_temp = readings[0][0]
    min_date = max_date = readings[0][1]
    for temp, date in readings[1:]:
        if temp > max_temp:
            max_temp = temp
            max_date = date
        elif temp < min_temp:        
            min_temp = temp
            min_date = date
    
    for location, readings in data.items():
        for temp, date in readings:
            if temp > max_temp:
                max_temp = temp
                max_location = location
                max_date = date
            elif temp < min_temp:
                min_temp = temp
                min_location = location
                min_date = date
    
    return {
        'max': {'temp': max_temp, 'location': max_location, 'date': max_date},
        'min': {'temp': min_temp, 'location': min_location, 'date': min_date}
    }


def save_summary(averages, extremes, output_filename):
    """Save summary statistics to a text file"""
    try:
        with open(output_filename, 'w') as file:
            
            # Title
            file.write("Temperature Measurement Summary\n")
            file.write("-" * 40 + "\n")
                        
            # Extremes
            file.write(">> Extreme Readings:\n")
            file.write(f"Highest: {extremes['max']['temp']:.2f}°C at {extremes['max']['location']} on {extremes['max']['date']}\n")
            file.write(f"Lowest: {extremes['min']['temp']:.2f}°C at {extremes['min']['location']} on {extremes['min']['date']}\n")

            # Averages
            file.write(">> Average Temperatures by Location:\n")          
            for location, avg in averages.items():
                file.write(f"{location}: {avg:.2f}°C\n")

        
        print(f"Summary saved to {output_filename}")
    
    except Exception as e:
        print(f"Error saving file: {e}")


# ------Main execution example ------

data = load_measurements('measurements.txt')
averages = calculate_average_per_location(data)
extremes = find_extreme_readings(data)
save_summary(averages, extremes, 'summary.txt')


# Focus: files, data aggregation, file writing
```
:::


[file](../codice/49.temperatures.py)



::: exefatti

Connect Four is played on a vertical grid (usually 7x6). 
Players take turns dropping colored discs into columns. The disc falls to the lowest available position. First player to connect 4 discs in a row (horizontal, vertical, or diagonal) wins.

Implement python functions for Board Creation and Display

Example output
```text
    
     1 2 3 4 5 6 7
    ---------------
    | | | | | | | |
    | | | | | | | |
    | | | | | | | |
    | | |O| | | | |
    | | |X| | | | |
    |O|X|X|O| | | |
    ---------------
     1 2 3 4 5 6 7

```



```python
EMPTY = ' '
PLAYER1 = 'X'
PLAYER2 = '0'
SYMBOLS = {0: EMPTY, 1: PLAYER1, 2: PLAYER2}


def create_board(rows, cols):
    """Create an empty Connect Four board."""
    board = []
    for row in range(rows):
        current_row = []
        for col in range(cols):
            current_row.append(0)
        board.append(current_row)
    return board

def display_board(board):
    """Display the board in a readable format."""
    
    # Display column numbers header
    column_numbers = ' '
    for i in range(1, len(board[0]) + 1):
        column_numbers += str(i) + ' '
    print(column_numbers)

    # Display separator line
    separator = '-' * (len(board[0]) * 2 + 1)
    print(separator)

    # Display board rows
    for row in board:
        row_str = '|'
        for cell in row:
            row_str += SYMBOLS[cell] + '|'
        print(row_str)
    
    # Display separator line
    separator = '-' * (len(board[0]) * 2 + 1)
    print(separator)
    
    # Display column numbers
    column_numbers = ' '
    for i in range(1, len(board[0]) + 1):
        column_numbers += str(i) + ' '
    print(column_numbers)



# ----  Test -------

board = create_board()
display_board(board)

```

Implement Move Validation and Execution 

```python
def is_valid_column(board, col):
    """Check if a move in the specified column is valid."""
    # Check bounds
    if col < 0 or col >= len(board[0]):
        return False
    # Check if top row is empty
    return board[0][col] == 0

def drop_disc(board, col, player):
    """Drop a disc into the specified column."""
    # Check if move is valid
    if not is_valid_column(board, col):
        return -1
    
    # Find lowest empty row (gravity)
    rows = len(board)
    for row in range(rows - 1, -1, -1): # start from last and go back (upwards)
        if board[row][col] == 0:
            board[row][col] = player
            return row
    
    return -1  # Should not reach here if is_valid_column works


# ---- Test ------

board = create_board()
drop_disc(board, 3, 1)
drop_disc(board, 3, 2)
display_board(board)

```
Implement win detection logic

```python
def check_horizontal(board, player):
    """Check if player has 4 in a row horizontally."""
    rows = len(board)
    cols = len(board[0])
    
    for row in range(rows):
        for col in range(cols - 3):  # Only check where 4 can fit
            if (board[row][col] == player and
                board[row][col+1] == player and
                board[row][col+2] == player and
                board[row][col+3] == player):
                return True
    return False

def check_vertical(board, player):
    """Check if player has 4 in a row vertically."""
    rows = len(board)
    cols = len(board[0])
    
    for row in range(rows - 3):  # Only check where 4 can fit
        for col in range(cols):
            if (board[row][col] == player and
                board[row+1][col] == player and
                board[row+2][col] == player and
                board[row+3][col] == player):
                return True
    return False

def check_diagonal(board, player):
    """Check if player has 4 in a row diagonally."""
    rows = len(board)
    cols = len(board[0])
    
    # Check / diagonals (bottom-left to top-right)
    for row in range(3, rows):
        for col in range(cols - 3):
            if (board[row][col] == player and
                board[row-1][col+1] == player and
                board[row-2][col+2] == player and
                board[row-3][col+3] == player):
                return True
    
    # Check \ diagonals (top-left to bottom-right)
    for row in range(rows - 3):
        for col in range(cols - 3):
            if (board[row][col] == player and
                board[row+1][col+1] == player and
                board[row+2][col+2] == player and
                board[row+3][col+3] == player):
                return True
    
    return False

def check_winner(board):
    """Check if any player has won."""
    for player in [1, 2]:
        if (check_horizontal(board, player) or
            check_vertical(board, player) or
            check_diagonal(board, player)):
            return player
    return 0


# --- Test. ------

board = create_board()
drop_disc(board, 0, 1)
drop_disc(board, 1, 1)
drop_disc(board, 2, 1)
drop_disc(board, 3, 1)
display_board(board)
print(f"Winner: {check_winner(board)}")


```
[file](../codice/50.connect4.py)


:::

::: exefatti

Implement a **text cipher** that applies multiple transformations based on a transformation code.

**Transformations:**
- `R` - Reverse the text
- `U` - Convert to uppercase
- `L` - Convert to lowercase
- `Sn` - Shift each letter by `n` positions (Caesar-style, but numbers specify shift)
- `W` - Swap every pair of characters

Example:
```text
input: "Hello World", "RU"  output: "DLROW OLLEH"
input: "Python", "S3"       output: "Sbwkrq"
input: "abcd", "W"          output: "badc"
input: "test", "S2RU"       output: "VWGX"
```

```python
ALPHALEN = 26  # alphabet chars
REVERSE = 'R'
UPPER = 'U'
LOWER = 'L'
SWAP = 'W'
SHIFT = 'S'

OPS = [REVERSE, UPPER, LOWER, SWAP, SHIFT]

def shift_char(base_string, shift):
    """Shift each character by shift positions"""
    
    new_string = ""

    for ch in base_string:
        if ch.isupper():
            shift_ch = chr((ord(ch) - ord('A') + shift) % ALPHALEN + ord('A'))
        elif ch.islower():
            shift_ch =  chr((ord(ch) - ord('a') + shift) % ALPHALEN + ord('a'))
        else:
            shift_ch = ch
        
        new_string += shift_ch
    return new_string


def apply_swap(text):
    """Swap every pair of characters"""
    result = ""
    for i in range(0, len(text), 2): 
        if i + 1 < len(text):
            result += text[i+1]
        result += text[i]
    return result

def encode(text, code):
    """Apply transformations in order"""
    result = text
    codelen = len(code)
    i = 0
    while i < codelen:
        # Reverse
        if code[i] == REVERSE:
            result = result[::-1]        
            i += 1
        # To upper
        elif code[i] == UPPER:
            result = result.upper()  
            i += 1
        # Lower
        elif code[i] == LOWER:
            result = result.lower()  
            i += 1
        # Swap
        elif code[i] == SWAP:
            result = apply_swap(result)
            i += 1
        # Shift
        elif code[i] == SHIFT:
            i += 1
            shift_str = ''
            while i < codelen and code[i].isdigit():
                shift_str += code[i]
                i += 1
            if shift_str:  # Added :
                shift = int(shift_str)  
            else:
                shift = 0
            result = shift_char(result, shift)
        else:
            print(f"Code {code[i]} not recognized!")
            i += 1
    return result


# ----- Test. ------

print(encode("Hello World", "RU"))       # "DLROW OLLEH"
print(encode("Python", "S3"))            # "Sbwkrq"
print(encode("abcd", "W"))               # "badc"

```

Implement also the `decode` function.

```python
def decode(text, code):
    """Reverse the transformations"""
    operations = []
    i = 0
    while i < len(code):
        if code[i] in OPS[:-1]:
            operations.append(code[i])
            i += 1
        elif code[i] == SHIFT:
            i += 1
            # Extract shift value
            shift_str = ''
            while i < len(code) and code[i].isdigit():
                shift_str += code[i]
                i += 1
            if shift_str:  
                shift = int(shift_str)  
            else:
                shift = 0
             # Store as tuple
            operations.append((SHIFT, shift)) 
        else:
            print(f"Code {code[i]} not recognized!")
            i += 1
    
    # Apply inverse operations in reverse order
    result = text
    for op in operations[::-1]:

        # Reverse
        if op == REVERSE:
            result = result[::-1]  # Reverse is its own inverse
        
        # Uppter / Lower
        elif op == UPPER or op == LOWER:
            # Can't reverse case changes without original:
            # "HELLO" might came from "hello" (all lowercase)
            # "HELLO" might came from "Hello" (mixed case)
            # "HELLO" might came from "HELLO" (already uppercase)
            pass
        
        # Swap
        elif op == SWAP:
            result = apply_swap(result)  # Swap is its own inverse

        # Shift
        else: # Must be tuple ('S', shift)
            result = shift_char(result, -op[1])  # Negative shift
    
    return result
```

[file](../codice/51.cipher.py)

:::

::: exefatti

Dataset of real passwords (made available from actual data breaches) sourced and compiled from `Information is Beautiful` and contributed to `R’s Tidy Tuesday project`. These passwords are common ("bad") passwords that you should avoid using.

The dataset has the following columns:

| variable          | class | description                                      
|-------------------|-------|-------------------------------------------------------------------------
|| rank              | int   | popularity in their database of released passwords                                                                      
| password          | str   | Actual text of the password
| catid             | int   | The category code the password falls into                                                   
| value             | float | Time to crack by online guessing                  
| time_unit         | str   | Time unit to match with value       
| offline_crack_sec | float | Time to crack offline in seconds                      
| rank_alt          | int   | Rank 2                     
| strength          | int   | Strength = quality of password where 10 is highest, 1 is lowest, please note that these are relative to these generally bad passwords

Portion of input file:
```
rank,password,catid,value,time_unit,offline_crack_sec,rank_alt,strength
1,password,7,6.91,years,2.17,1,8
2,123456,9,18.52,minutes,1.1100000000000002e-5,2,4
3,12345678,9,1.29,days,0.00111,3,4
4,1234,9,11.11,seconds,1.1099999999999999e-7,4,4
5,qwerty,9,3.72,days,0.00321,5,8
6,12345,9,1.85,minutes,1.11e-6,6,4
```

| variable          | class | description                                      
|-------------------|-------|-------------------------------------------------------------------------
| id                | int   | Category identifier                           
| category          | str   | Category name


```
id,category
1,animal
2,cool-macho
3,fluffy
4,food
5,name
6,nerdy-pop
7,password-related
8,rebellious-rude
9,simple-alphanumeric
10,sport
11,color
```

Tasks and queries to be performed


## 1.
Load the dataset stored in the `passwords.txt.csv` file, having as a first row column names. Load the information on the password categories used in the classification, stored in the `passwords.cat.csv` file.
Transform online crack time in uniform scale.
Display information on the number of passwords reported in the data set.

```python
import pandas as pd

DATAFOLDER = "GIT-cs2025-26/codice/files/data_passwords/"

FNAMEDATA = DATAFOLDER + "passwords.txt.csv"
FNAMECAT = DATAFOLDER + "passwords.cat.csv"

df = pd.read_csv(FNAMEDATA)
df_cat = pd.read_csv(FNAMECAT)



print(f"Number of passwords in dataset: {df.shape[0]}")
print(f"Number of columns: {df.shape[1]}")
print("DF sample:")
print(df.sample(10))


# Transform time in uniform scale
TIMECONV = {'seconds': 1,
            'minutes': 60,
            'hours': 3600,
            'days': 86400,
            'weeks': 604800,
            'months': 2592000,
            'years': 31536000
            }

df['online_crack_secs'] = df['time_unit'].map(TIMECONV) * df['value']

# Alternative with lambda
# df['online_crack_secs'] = df.apply(lambda row: int(row['value'] * TIMECONV[row['time_unit']]), axis=1)


# Drop legacy columns
df = df.drop(columns=['time_unit', 'value'])
print(df.sample(10))
```







## 2. 

Find all passwords in the "animal" and "sport" categories that:

* Have a strength >= 7
* Take less than 1 hour to crack offline
* Contain at least one digit

For these passwords, show: password, category name, strength, and offline_crack_sec.

```python
#  Merge dataframes
df_merged = pd.merge(df, df_cat, left_on='catid', right_on='id', how='inner')

# Create filter conditions
target_categories = df_merged['category'].isin(['sport', 'animal'])
strong_passwords = df_merged['strength'] >= 7
fast_crack = df_merged['offline_crack_sec'] < 1*TIMECONV['hours']  # 1 hour in seconds

# define a function
def contains_digit(row_string):
    for ch in row_string:
        if '0' <= ch <= '9':
            return True
    return False
# Apply the function row-wise
has_digit = df_merged['password'].apply(contains_digit)

# Alternatives
# has_digit = df_merged['password'].map(lambda s: any(ch.isdigit() for ch in s))
# has_digit = df_merged['password'].str.contains(r'\d', regex=True)


# Apply all filters
df_result2 = df_merged[target_categories & strong_passwords  & has_digit & fast_crack][[]]
print(df_result2[['password', 'category', 'strength', 'offline_crack_sec']])

# Alternative using loc
# df_result2 = df_merged.loc[
#     target_categories & strong_passwords & fast_crack & has_digit,
#     ['password', 'category', 'strength', 'offline_crack_sec']
# ]
# print(df_result2)

```


## 3.
For each password category, calculate the **average strength** and the **percentage of passwords** that take more than 1 day to crack online. Display results in format `category | avg_strength | pct_over_1day`,  sorted by average strength (descending).


```python

# Create a column to identify passwords over 1 day
df_merged['over_1day'] = df_merged['online_crack_secs'] > 1*TIMECONV['days']

# Group by category and calculate metrics
df_stats = df_merged.groupby('category').agg(
    avg_strength=('strength', 'mean'),
    tot_passwords=('password', 'count'),
    tot_over_1day=('over_1day', 'sum')  # sum of True values
).reset_index()


# Alternative
# df_stats_a  = df_merged.groupby('category')['strength'].mean().reset_index().rename(columns={'strength':'avg_strength'})
# df_stats_b  = df_merged.groupby('category')['password'].count().reset_index().rename(columns={'password':'tot_passwords'})
# df_stats_c  = df_merged.groupby('category')['over_1day'].sum().reset_index().rename(columns={'password':'tot_over_1day'})
# df_stats = df_stats_a.merge(df_stats_b, on='category').merge(df_stats_c, on='category')

#Calculate percentage
df_stats['pct_over_1day'] = df_stats['tot_over_1day'] / df_stats['tot_passwords'] * 100



# Sort and display
df_result3 = df_stats.sort_values('avg_strength', ascending=False)
print(df_result3[['category', 'avg_strength', 'pct_over_1day']])

```


 
## 4.
Analyze the relationship between password **length** and **security** across categories.
Create `length_category` column with cases: 'short' (1-4 chars), 'medium' (5-7 chars), 'long' (7+ chars)

For each password category and length category combination, calculate:
* Average strength
* Average offline crack time
* Count of passwords

Display results for categories with at least 10 passwords in each length category
Which password category shows the biggest strength improvement from short to long passwords?

```python

# Add password length category
def categorize_length(password):
    if len(password) <= 4:
        return 'short'
    elif len(password) <= 7:
        return 'medium'
    else:
        return 'long'

df_merged['length_category'] = df_merged['password'].apply(categorize_length)


# Group by category and length_category
df_length_analysis = df_merged.groupby(['category', 'length_category']).agg(
    avg_strength=('strength', 'mean'),
    avg_offline_crack_sec=('offline_crack_sec', 'mean'),
    password_count=('password', 'count')
).reset_index()


# Filter categories with at least 10 passwords in each length category
# > First, count number of length categories and minimum password count per category 
category_counts = df_length_analysis.groupby('category').agg(
    min_count=('password_count', 'min'),
    num_length_cats=('length_category', 'count')
).reset_index()
# > Then, filter categories satisfying both conditions
valid_categories = category_counts.loc[
    (category_counts['min_count'] >= 10) & (category_counts['num_length_cats'] == 3),
    'category'
]

# Final result filtering and sorting
df_result4 = df_length_analysis.loc[df_length_analysis['category'].isin(valid_categories)]
df_result4 = df_result4.sort_values(['category', 'length_category'])
print(df_result4)

```


## 5. 
For each password category, analyze the distribution of password strengths by calculating what percentage falls into each strength tier.
Find which category has the highest percentage of 'strong' passwords.
Display a summary table with categories sorted by their 'strong' percentage.
:::

## Proposed exercises

::: exepro

Write functions to validate a Sudoku puzzle solution.

A valid 9x9 Sudoku has:
- Each row contains digits 1-9 exactly once
- Each column contains digits 1-9 exactly once  
- Each 3x3 sub-grid contains digits 1-9 exactly once

(convention: 0 -> 'empty cell')

**Example input:**
```bash
5  3  4  6  7  8  9  1  2 
6  7  2  1  9  5  3  4  8  
1  9  8  3  4  2  5  6  7  
8  5  9  7  6  1  4  2  3  
4  2  6  8  5  3  7  9  1  
7  1  3  9  2  4  8  5  6  
9  6  1  5  3  7  2  8  4  
2  8  7  4  1  9  6  3  5  
3  4  5  2  8  6  1  7  9
```


```python
ROWCOL = 3
DIM = ROWCOL * ROWCOL


def is_valid_row(board, row_index):
    """Check if row is valid"""
    row = board[row_index]
    # Filter out empty cells (0)
    filled = []
    for cell in row:
        if cell != 0:
            filled.append(cell)
    # Check for duplicates using set
    return len(filled) == len(set(filled))

def is_valid_column(board, col_index):
    """Check if column is valid"""
    column = []
    for row in range(DIM):
        column.append(board[row][col_index])
    
    filled = []
    for cell in column:
        if cell != 0:
            filled.append(cell)
    
    return len(filled) == len(set(filled))


def is_valid_column_v2(board, col_index):
    """Check if column is valid"""
    cont = [0]*DIM
    for row in range(DIM):
        val = board[row][col_index]
        if val != 0: 
            cont[val-1] += 1
    for i in range(DIM):
        if cont[i] > 1:
            return False
    return True


def is_valid_subgrid(board, start_row, start_col):
    """Check 3x3 grid"""
    cells = []
    for i in range(start_row, start_row + ROWCOL):
        for j in range(start_col, start_col + ROWCOL):
            if board[i][j] != 0:
                cells.append(board[i][j])
    return len(cells) == len(set(cells))

def is_valid_sudoku(board):
    """Check entire board"""
    # Check all rows
    for i in range(DIM):
        if not is_valid_row(board, i):
            return False
    
    # Check all columns
    for j in range(DIM):
        if not is_valid_column(board, j):
            return False
    
    # Check all 3x3 subgrids
    for i in range(0, DIM, ROWCOL):
        for j in range(0, DIM, ROWCOL):
            if not is_valid_subgrid(board, i, j):
                return False
    
    return True



# ----- Test --------
valid_board = [
    [5,3,4,6,7,8,9,1,2],
    [6,7,2,1,9,5,3,4,8],
    [1,9,8,3,4,2,5,6,7],
    [8,5,9,7,6,1,4,2,3],
    [4,2,6,8,5,3,7,9,1],
    [7,1,3,9,2,4,8,5,6],
    [9,6,1,5,3,7,2,8,4],
    [2,8,7,4,1,9,6,3,5],
    [3,4,5,2,8,6,1,7,9]
]

print(is_valid_sudoku(valid_board))  # True

```

[file](../codice/90.sudoku.py)

:::