---
exe-start: 22
exepro-start: 34
---

# Python: functions

+ objectives: problem decomposition, abstraction and complexity handling, reuse
+ variable scope and visibility

### Details

+ modifiable input parameters

## Exercises in class

::: exefatti

Two strings are _compatible_ if they have the same length and contain the same character in the same position, except when there is a space.

Write a Python function that receives two strings as input and returns True if the strings are compatible, False otherwise. The strings contain only lowercase alphabetic characters and spaces. Examples:

```
seq1: "compatible"
seq2: "c mp t ble"
output: True

seq1: "compatible"
seq2: "c mp t bles"
output: False

seq1: "exam les"
seq2: "e amp es"
output: True
```

```python
def compatiblestrings(seq1, seq2):
	size = len(seq1)

	if (size != len(seq2)):
		return False

    # Iterate through the strings character by character
    for i in range(size):
        # If characters are different and neither is a space, they are not compatible
        if seq1[i] != seq2[i] and seq1[i] != ' ' and seq2[i] != ' ':
            return False
    # If the loop completes, the strings are compatible
    return True
```

[file](../codice/26.sub.compatiblestrings.py)

:::

::: exefatti

Write a function `validateParentheses` to determine if a given string contains balanced round parentheses. The function returns True if the string is valid, and False otherwise. Note that every opening parenthesis "(" has a corresponding closing parenthesis ")". Examples:

```
input: "((this is(a test)))"
output: True

input: ")another test("
output: False

input: "((this is)(a test)(again()))check"
output: False
```

```python
OPEN = '('
CLOSE = ')'

def validateParentheses (seq):

	#number of open parentheses
	num = 0
	# for every element, increment/decrement the number of open parentheses
	for elem in seq:
		if elem == OPEN:
			num += 1
		elif elem == CLOSE:
			num -= 1
		# if there are more closed parentheses than open ... validation False
		if num < 0:
			return False

	# there is an unbalanced open parentheses
	if num > 0:
		return False

	# all parentheses are balanced
	return True
```

[file](../codice/27.sub.parentheses.py)

:::

::: exefatti

Write a Python function that receives in input a list and modifies it so that all elements in an odd position if they are odd, are put to 0. Examples:

```
list in input: []
list at the end: True

input: ")another test("
output: False

input: "((this is)(a test)(again()))check"
output: False
```

```python
def nullodds(values):
    size = len(values)
    for i in range(size):
        if i % 2 == 0:  # it is in odd position
            # if the element's value is odd
            if my_list[i] % 2 != 0:
                my_list[i] = 0
```

[file](../codice/28.sub.nullodds.1.py)

More effective way, iterating only on odd elements.

```python
def nullodds(values):
    size = len(values)
    for i in range(1, size, 2):	# check only odd elements
        # if the element's value is odd
        if my_list[i] % 2 != 0:
            my_list[i] = 0
```

[file](../codice/28.sub.nullodds.2.py)

Erroneous solution: it does not modify the value in the list

```python
def nullodds(values):
	i = 0
    for val in values:
    	if i % 2 == 0:  # it is in odd position
    		if val % 2 != 0:
    			val = 0
```


:::

## Proposed exercises

::: exepro

:::

::: exepro

:::