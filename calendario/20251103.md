---
exe-start: 26
exepro-start: 41
---

# Python: functions -- continued

+ objectives: problem decomposition, abstraction and complexity handling, reuse
+ variable scope and visibility

### Details

+ modifiable input parameters

## Exercises in class

::: exefatti

**Q1**: Are the two versions of the elaboration equivalent?

```python
sequence = []
# fill the list with relevant values
# ...

for i in range(len(sequence)):
	if sequence[i] < threshold:
		sequence[i] = sequence[i] * sequence[i]

for elem in sequence:
	if elem < threshold:
		elem = elem * elem
```

+ [x] No, they do not perform the same functionality
+ [ ] Yes, they perform the same functionality BUT they are different in terms of performance/effort
+ [ ] Yes, they perform the same functionality and are similar in terms of performance/effort

[file](../codice/26.selfcheck.py)

::: 

::: exefatti

Two strings are _compatible_ if they have the same length and contain the same character in the same position, except when there is a space.

Write a Python function that receives two strings as input and returns True if the strings are compatible, False otherwise. The strings contain only lowercase alphabetic characters and spaces. Examples:

```
seq1: "compatible"
seq2: "c mp t ble"
output: True

seq1: "compatible"
seq2: "c mp t bles"
output: False

seq1: "exam les"
seq2: "e amp es"
output: True
```

```python
JOLLY = ' '

def compatiblestrings(seq1, seq2):
	size = len(seq1)

	if (size != len(seq2)):
		return False

    # Iterate through the strings character by character
    for i in range(size):
        # If characters are different and neither is a space, they are not compatible
        if seq1[i] != seq2[i] and seq1[i] != JOLLY and seq2[i] != JOLLY:
            return False
    # If the loop completes, the strings are compatible
    return True
```

[file](../codice/27.sub.compatiblestrings.1.py)

Version with first the case of equal size strings and computation, then the anomaly of two strings with different sizes.

```python
JOLLY = ' '

def compatible(seq1, seq2):
    dim = len(seq1)

    if len(seq2) == dim:
        # same size, investigate further
        # I assume they are compatible, look for a violation of the rule 
        comp = True
        # for every position in the strings
        for pos in range(0, dim):
            # if the characters are different and neither of them is a space
            if seq1[pos] != seq2[pos] and (seq1[pos] != JOLLY and seq2[pos] != JOLLY):
#           if seq1[pos] != seq2[pos] and not(seq1[pos] == JOLLY or seq2[pos] == JOLLY):
                # the strings are not compatible
                comp = False
                break
                # interrupt, we know the answer
        # if I got to the end without encountering a problem, the strings
        # are compatible
    else:
        # different size, they are not compatible
        comp = False
        
    #return the result
    return comp
```

[file](../codice/27.sub.compatiblestrings.2.py)

Version with a `while` loop

```python
JOLLY = ' '

def compatible(seq1, seq2):
    dim = len(seq1)

    if len(seq2) == dim:
        # same size, investigate further
        # I assume they are compatible, look for a violation of the rule 
        comp = True
        # for every position in the strings
        pos = 0
        while pos < dim and comp == True:
            # if the characters are different and neither of them is a space
            if seq1[pos] != seq2[pos] and (seq1[pos] != JOLLY and seq2[pos] != JOLLY):
#           if seq1[pos] != seq2[pos] and not(seq1[pos] == JOLLY or seq2[pos] == JOLLY):
                # the strings are not compatible
                comp = False
            else
                pos += 1

        # if I got to the end without encountering a problem, the strings
        # are compatible
    else:
        # different size, they are not compatible
        comp = False
        
    #return the result
    return comp
```

[file](../codice/27.sub.compatiblestrings.3.py)

:::

::: exefatti

Write a Python function that receives in input a list and modifies it so that all elements in an odd position if they are odd, are put to 0. Examples:

```
list in input: [1, 3, 5, 3, 4, 5, 5, 1, 0, 4, 7, 8, 10]
list at the end: [1, 0, 5, 0, 4, 0, 5, 0, 0, 4, 7, 8, 10]

```

```python
def nullodds(values):
    size = len(values)
    for i in range(size):
        if i % 2 == 0:  # it is in odd position
            # if the element's value is odd
            if values[i] % 2 != 0:
                values[i] = 0
```

[file](../codice/28.sub.nullodds.1.py)

More effective way, iterating only on odd elements.

```python
def nullodds(values):
    size = len(values)
    for i in range(1, size, 2):	# check only odd elements
        # if the element's value is odd
        if values[i] % 2 != 0:
            values[i] = 0
```

[file](../codice/28.sub.nullodds.2.py)

Erroneous solution: it does not modify the value in the list

```python
def nullodds(values):
	i = 0
    for val in values:
    	if i % 2 == 0:  # it is in odd position
    		if val % 2 != 0:
    			val = 0
```
:::

::: exefatti

Write a Python function that receives a string in input, followed by three characters, `fromc`, `toc` and `replc`. The function computes and returns a new string where all characters included in the interval `[fromc, toc]` boundaries included, are replaced with the third character `replc`.


```python
def replaceininterval(seq, fromc, toc, replc):
    newseq = ""
    # for every element in the string
    for elem in seq:
        # if it is included in the interval, boundaries included
        if elem >= fromc and elem <= toc:
#       if fromc <= elem <= toc:        
            # append the replacement character
            newseq += replc
        else:
            # append the original character
            newseq += elem
    return newseq

mystr = "this is a test for my function"
res = replaceininterval(mystr, 'c', 'm', 'x')
print(res)
```


[file](../codice/29.sub.replaceininterval.py)

Considerations on the fact that not only a string is not modifiable, but the visibility
of the parameter is limited to the function itself. Even if we assign a new value to the parameter, it will not be visible outside.

```python
def replaceininterval(seq, fromc, toc, replc):
    #any computation
    seq = newseq
```

```python
def replaceininterval(seq, fromc, toc, replc):
    newseq = ""
    # for every element in the string
    for elem in seq:
        # if it is included in the interval, boundaries included
        if elem >= fromc and elem <= toc:
#       if fromc <= elem <= toc:        
            # append the replacement character
            newseq += replc
        else:
            # append the original character
            newseq += elem
    seq = newseq

mystr = "this is a test for my function"
replaceininterval(mystr, 'c', 'm', 'x')
print(mystr) #exactly as the string in input to the function
```

:::

## Proposed exercises

::: exepro

Write a function `validateParentheses` to determine if a given string contains balanced round parentheses. The function returns True if the string is valid, and False otherwise. Note that every opening parenthesis "(" has a corresponding closing parenthesis ")". Examples:

```
input: "((this is(a test)))"
output: True

input: ")another test("
output: False

input: "((this is)(a test)(again()))check"
output: False
```

```python
OPEN = '('
CLOSE = ')'

def validateParentheses (seq):

    #number of open parentheses
    num = 0
    # for every element, increment/decrement the number of open parentheses
    for elem in seq:
        if elem == OPEN:
            num += 1
        elif elem == CLOSE:
            num -= 1
        # if there are more closed parentheses than open ... validation False
        if num < 0:
            return False

    # there is an unbalanced open parentheses
    if num > 0:
        return False

    # all parentheses are balanced
    return True
```

[file](../codice/90.sub.parentheses.py)

:::

::: exepro
Write a Python function that receives in input a strictly positive integer and computes and returns the list of its _proper divisor_s. Recall a _proper divisor_ of a positive integer `n` is any positive divisor of `n` other than `n` itself.

```python
def properdivisors(val):
	pd = []
	for i in range(1, val):
		if val % i == 0:
			pd.append(i)

	return pd
```

[file](../codice/90.properdivisors.py)

:::

::: exepro

Write a Python function that receives in input two strings that have a single character in common. The function finds and returns such a character.

```python
def commoncharacter(seq1, seq2):
	for c in seq1:
		if c in seq2:
			return c
#	guaranteed to find one by problem constraints	
	return None
```

[file](../codice/90.commonchar.1.py)

Version 2: uselessly complex and expensive

```python
def commoncharacter(seq1, seq2):
    elem1 = set(seq1)
    elem2 = set(seq2)

    c = elem1.intersection(elem2)
	return c
```

[file](../codice/90.commonchar.2.py)

:::

::: exepro
Write a Python function that receives in input a string that represents a password. The password is considered valid if all three conditions are met:
+ it contains at least a capital letter and a small letter
+ it contains at least a digit
+ it does not have two adjacent identical characters

The function returns `True` or `False` based on the password being valid or not.

:::

```python
def validPassword(pwd):
    dim = len(pwd)

    hasCap = pwd[0].isupper()
    hasSmall = pwd[0].islower()
    hasDigit = pwd[0].isdigit()
    adjacentEqual = False
    i = 1
    while i < dim and not (hasCap and hasSmall and hasDigit):
        if not hasCap and pwd[i].isupper():
            hasCap = True
        if not hasSmall and pwd[i].islower():
            hasSmall = True
        if not hasDigit and pwd[i].isdigit():
            hasDigit = True
        if pwd[i-1] == pwd[i]:
            adjacentEqual = True
            break
        i += 1

    #why am I here?
    result = hasCap and hasSmall and hasDigit and not adjacentEqual
    return results
```

[file](../codice/90.sub.validpassord.py)


::: exepro

A list of lists describes a map representing the altitude of a territory. Each element of the data structure represents a land area and its value (a float) represents its average altitude in meters.
*Definition*: A **maximum landslide risk point** is the point where there is the maximum elevation difference with respect to one of its _adjacent points_. _Adjacent points_ are those elements whose coordinates differ by 1 in one or both indices (including diagonal neighbors).
Consider as an example the map represented below:

|       |       |       |       |       |       |       |       |       |        |
|-------|-------|-------|-------|-------|-------|-------|-------|-------|--------|
| 90.63 | 37.81 | 31.08 | 66.97 | 72.15 | 14.50 | 89.89 | 84.26 | 84.60 | 21.83  |
| 90.41 | 65.41 | 77.28 | 42.58 | 36.68 | 24.04 | 67.79 | 89.28 | 90.34 | 69.86  |
| 24.98 | 10.92 | 83.42 | 5.52  | 28.58 | 75.20 | 83.78 | 88.33 | 32.92 | 80.16  |
| 39.19 | 23.55 | 17.98 | 70.28 | 90.52 | 90.13 | 84.78 | 80.41 | 74.39 | 69.38  |
| 45.02 | 85.73 | 4.82  | 28.45 | 91.25 | 33.40 | 3.65  | 75.03 | 21.20 | 36.57  |
| 55.20 | 60.92 | 60.12 | 73.17 | 31.20 | 50.64 | 63.30 | 15.98 | 31.05 | 37.69  |
| 85.36 | 33.29 | 2.49  | 20.15 | 12.81 | 9.87  | 91.63 | 16.37 | 85.03 | 52.39  |
| 10.27 | 30.06 | 38.12 | 15.09 | 58.50 | 29.37 | 48.48 | 62.15 | 4.40  | 70.21  |
| 98.72 | 59.60 | 31.12 | 58.84 | 32.77 | 62.32 | 9.48  | **96.07** | 78.30 | 40.53  |

The **maximum risk point** is the element in bold because the difference between 96.07 and 4.40 is the maximum in the entire data structure.
Write a function `risk` that receives as input the terrain map and calculates and returns the coordinates of the maximum landslide risk position and the value of the maximum elevation difference.

Write a program that calls function `risk` passing a map and visualises the coordinates of the maximum risk point, the maximum difference and the altitude of the point

```python
def risk(tmap):    
    rows = len(tmap)
    cols = len(tmap[0])
    
    # the first element is the one with the highest risk
    max_diff = 0
    maxposi = 0
    maxposj = 0
    
    # Iterate through each point in the map
    for i in range(rows):
        for j in range(cols):
            current_altitude = tmap[i][j]
            # Check all adjacent points (including diagonals)
            for di in [-1, 0, 1]:
                for dj in [-1, 0, 1]:                    
                    # Calculate neighbor coordinates
                    ni = i + di
                    nj = j + dj
                    # Check if neighbor is within bounds
                    if 0 <= ni < rows and 0 <= nj < cols:
                        neighbor_altitude = tmap[ni][nj]
                        diff = abs(current_altitude - neighbor_altitude)
                        # Update maximum if this difference is larger
                        if diff > max_diff:
                            max_diff = diff
                            maxposi = i
                            maxposj = j
    
    return max_position, max_diff


# Test with the example map
terrain = [
    [90.63, 37.81, 31.08, 66.97, 72.15, 14.50, 89.89, 84.26, 84.60, 21.83],
    [90.41, 65.41, 77.28, 42.58, 36.68, 24.04, 67.79, 89.28, 90.34, 69.86],
    [24.98, 10.92, 83.42, 5.52, 28.58, 75.20, 83.78, 88.33, 32.92, 80.16],
    [39.19, 23.55, 17.98, 70.28, 90.52, 90.13, 84.78, 80.41, 74.39, 69.38],
    [45.02, 85.73, 4.82, 28.45, 91.25, 33.40, 3.65, 75.03, 21.20, 36.57],
    [55.20, 60.92, 60.12, 73.17, 31.20, 50.64, 63.30, 15.98, 31.05, 37.69],
    [85.36, 33.29, 2.49, 20.15, 12.81, 9.87, 91.63, 16.37, 85.03, 52.39],
    [10.27, 30.06, 38.12, 15.09, 58.50, 29.37, 48.48, 62.15, 4.40, 70.21],
    [98.72, 59.60, 31.12, 58.84, 32.77, 62.32, 9.48, 96.07, 78.30, 40.53]
]

posi, posj, difference = pericolo(terrain)
print(f"Position: {posi},{posj}")
print(f"Difference: {difference:.2f}")
print(f"Altitude: {terrain[posi][posj]:.2f}")
```

[file](../codice/90.risk.py)


::: 